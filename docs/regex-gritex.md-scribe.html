<!DOCTYPE HTML>
<html>
<head>
<meta lang=en charset="UTF-8">
<style>
body {
    font-family: 'Helvetica Neue', Helvetica, Arial, serif;
    font-size: 1em; line-height: 1.5; color: #505050;
}
.code { background: whitesmoke; margin:0pt 10pt;}
blockquote {border-left: solid thick gainsboro; padding-left:5pt;}
h1,h2,h3,h4 {border-bottom: thin solid gainsboro; }
.key-val { margin:0px; }
.key-val-blk { margin:0px; margin-left:20pt; }
[data-tight='false'] > li {margin-bottom:12pt;}
q { quotes: "“" "”" "‘" "’"; }

</style>
<script>
// grit-parser loads itself into: window.grit_parser
// Grammar Parser -- an evolution of Grit.

// See docs at: https://github.com/pcanz/grammar-parser

/*	The MIT License (MIT)
 *
 *	Copyright (c) 2015,2016,2017,2018,2019 Peter Cashin
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files(the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 *	furnished to do so, subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included
 *	in all copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 *	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

;(function() { // module name-space wrapper -- see the end of this file...

/* -- grammar-rule grammar ---------------------------------------

    grammar = rule+
    rule    = name "=" expr ws act?

    expr    = seq ("/" seq)*
    seq     = (ws [&!]? term [*+?]?)*
    term    = ref / quote / regex / group

    name    = ws \w+
    ref     = name !\s*=
    group   = "(" expr ")"

    quote   = '"' [^"]* '"' / "'" [^']* "'"
    regex   = &[[\\^] (chs / par / misc)+
    chs     = [\[] ([^\]\\]* ([\\][^])?)+ [\]]
    par     = [(] ([^()]* par?)* [)]
    misc    = [^[()\s]+

    act     = ":" lines
    lines   = line (\s* !\S+\s*= line)*
    line    = [^\n\r]* 
    ws      = \s*  
*/

// -- parser code for grit_rules --------------------------------------

// The parser is a byte-code style interpreter, but encodes
// instructions an array data structure with string values.

/* parser instruction codes:

    ["^", "regex"]      match regexp
    ["=", rule]         call rule by name.
    [",", a, b, c, ...] sequence of instruction codes, all to succeed.
    ["/", a, b, c, ...] alternatives, first to succeed.
    ["+", x]            matches one or more x, or fails.
    ["*", x]            matches any number of x, none matches "".
    ["?", x]            optional match: x / ""
    ["&", x]            lookahead: "" if x matches, else fails.
    ["!", x]            negation: fails if x matches, else "".
    
    The parser compiles rule names to rule indexes on the fly, and also
    compiles regexp's on the fly (to keep the code simple, and portable).

    The parser code can be exported as JSON.
*/

const grit_code = [
    {   name: "__grit__grammar", // grammar = rule+
        code: ["+",["=","rule"]] },

    {   name: "rule", // rule = name "=" expr ws act?
        code: [",",["=","name"],["^","\\s*="],["=","expr"],
                        ["=", "ws"],["?",["=","act"]]] },

    {   name: "expr", // expr = seq ("/" seq)*
        code: [",",["=","seq"],["*",[",",["^","\\s*/"],["=","seq"]]]] },

    {   // seq = (ws [&!]? term [*+?]?)*
        name: "seq",
        code: ["*",[",",["=","ws"],["^","[&!]?"],["=","term"],["^","[*+?]?"]]] },

    {   name: "term", // term = ref / quote/ regex / group
        code: ["/",["=","ref"],["=","quote"],["=","regex"],["=","group"]] },

    {   name: "name", // name = ws \w+
        code: [",",["^","[\\s]*"],["^","[\\w]+"]] },

    {   name: "ref", // ref = name !\s*=
        code: [",",["=","name"],["!",["^","[\\s]*="]]] },

    {   name: "quote", // quote = '"' [^"]* '"' / "'" [^']* "'"
        code: ["^","\\s*((?:'[^']*'|\"[^\"]*\")[\\w]*)"] },

    {   name: "regex", // regex = &[[\\^] (chs / par / misc)+
        code: [",",["&",["^","[[\\\\^]"]],["+",["/",["=","chs"],["=","par"],["=","misc"]]]] },

    {   name: "chs", // [\[] ([^\]\\]* ([\\][^])?)+ [\]]
        code: ["^","[[](?:[^\\]\\\\]*(?:[\\\\][^])?)+[\\]]"] },

    {   name: "par", // par = [(] ([^()]* par?)* [)]
        code: [",",["^","[(]"],["*",[",",["^","[^()]*"],["?",["=","par"]]]],["^","[)]"]] },

    {   name: "misc", // [^[()\s]+
        code: ["^","[^[()\\s]+"] },

    {   name: "group", // group = "(" expr ")"
        code: [",",["^","\\s*\\("],["=","expr"],["^","\\s*\\)"]] },

    {   name: "act", // act = ":" lines
        code: [",",["^","\\s*:"],["^","[^\\n\\r]*"], // line = [^\n\r]*
                ["*",[",",["^","\\s*"],["!",["^","\\S+\\s*="]],
                            ["^","[^\\n\\r]*"]]]] },

    {   name: "ws", // ws = \s* 
        code: ["^","\\s*"] }
];

resolve_code(grit_code); // maps names to indexes & compiles regexes

// -- compile peg rules into parser instruction codes --------------------

const grit_actions = { // semantic actions for parse tree nodes...

    // grammar = rule+
    "grammar": (rs) => rs,

    // rule = name "=" expr ws act?
    "rule": ([name, _, code, ws, action]) => {
        return {name, code, action};
    },

    // expr = seq ("/" seq)*
    "expr": ([seq, alts]) => {
        if (alts.length === 0) {
            return seq;
        } else {
            var seqs = alts.map(([_, seq]) => seq)
            return ["/", seq, ...seqs];
        }
    },

    // seq = (ws [&!]? term [*+?]?)*
    "seq": (xs) => {
        var ts = xs.map(([ws, pred, term, rep]) => {
            if (rep) { term = [rep, term]; }
            if (pred) { term = [pred, term];}
            return term;
        })
        if (ts.length === 1) return ts[0];
        return [",", ...ts];
    },

    // term = ref / match / group
    "term": (x) => x,

    // name = ws \w+
    "name": ([_, name]) => name,

    // ref = name !\s*=
    "ref":  ([name, _]) => ["=", name, null],

    // group = "(" expr ")"
    "group": ([_, expr]) => expr,

    // quote = '"' [^"]* '"' / "'" [^']* "'"
    "quote": (str) => { // quote => regex: \s*("...")\s*
        if (str.length === 2) { // empty quotes..
            return (str[0] === "'")? ["^","\uFFFF?"] : ["^","\\s*(\uFFFF?)"];
        }
        qt = str.slice(1,-1);
        if (str[0] === "'") return ["^",esc_regex(qt)];
        return ["^","\\s*("+esc_regex(qt)+")\\s*"];
    },

    // // regex   = &[[\\^] (chs / par / misc)*
    // "regex": ([_, rs]) => rs[0]==='^'? 
    //             ["^", rs.slice(1).join('')] : ["^", rs.join('')],

    // regex   = &[[\\^] (chs / par / misc)*
    "regex": ([_, rs]) => rs[0] && rs[0][0]==='^'? 
                ["^", rs[0].slice(1)+rs.slice(1).join('')]
                : ["^", rs.join('')],

    // par = [(] ([^()]* par?)* [)]
    "par": ([lp, ps, rp]) => { // par? => p, will be already done..
        var xps = ps.map(([x, p]) => p? x+p : x);
        return lp + xps.join('') + rp; 
    },

    // act = ":" lines
    "act": ([_, line, lines]) => {
        return string([line, lines]);
    },

    // ws = \s*
    "ws": (s) => s

} // grit_actions

function esc_regex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function rules_map(code) {
    return code.reduce((rm, rule, idx) => {
        rm[rule.name] = idx; return rm; }, {});
}

function resolve_code(code) {
    var name_idx = rules_map(code);

    function resolve (op) {
        if (!Array.isArray(op)) return op;
        if (op[0] === "^") {
            op[2] = op[2] || new RegExp(op[1],"yus"); // sticky unicode dots flags
            return op;
        }
        if (op[0] === "=") {
            op[2] = name_idx[op[1]];
            if (!op[2] && op[2]!==0) {
                throw new Error("*** missing rule '"+op[1]+"' ... ")
            }
            return op;
        }
        return op.map((x) => resolve(x));
    }
    var coded = code.map((rule) => {
        return resolve(rule.code);
    });

    return code;
}
    
// -- parser -- string-code interpreter ------------------------------------

const ANON = "__anon__"; // default name for first rule

function parser (code, input, actions={}, options={}) {
    var pos = 0;
    var inRule = "start"; // current rule trace 
    var ruleStack = [];
    var maxPos = 0; // high water mark
    var maxRule= ""; // inRule at maxPos
    var runOps = 0;
    var maxOps = 10000; // run away recursion check

    if (!code) {
        return report("missing grammar rule code...");
    }

    var start_name = code[0].name;
    var start = ["=", start_name, 0];

    if (typeof input !== "string") {
        try { // tag`grammar..` => tag([grammar...], ${}...)
            input = String.raw(input);
            if (!input.match(/^\s*\S+\s*=/)) {
                input = ANON+" = "+input; // simple regex grammar
            }
        } catch(err) {
            input = '';
            return report("input is not a string...");
        }
    }

    if (typeof actions === 'function') {
        actions = { "?": actions } // catch all
    }

    if (options.trace) console.log("trace", start_name)

    var result = run(start); // run the parser engine...

    if (result === null) {
        return report("failed");
    }
    if (pos < input.length && !input.slice(pos).match(/^\s+$/)) {
        if (options.replay) replay();
        return report("fell short");
    }
    return [result, pos];

    // -- code engine -------------------------------------------

    function run(op) {

        if (runOps += 1 > maxOps) {
            return report("run away recursion...");
        }

        switch (op[0]) {

        case '^': // ["^", src, regex]
            var regex = op[2]; 
            regex.lastIndex = pos; // using regex.y sticky flag
            var mx = regex.exec(input);
            var trace = options.trace;
            if (trace) {
                if (typeof trace !== "string" || trace === inRule) {
                    var span = pos;
                    span += mx? ".."+(pos+mx[0].length) : ""
                    var match = mx? "=>"+mx[0] : "!";
                    console.log(span,inRule,regex,match);
                }
            }
            if (!mx) return null;
            pos += mx[0].length;
            if (pos > maxPos) { 
                maxPos = pos; 
                maxRule = inRule;
            }
            // return mx[1]||mx[0]; // used to skip white-space prefix
            if (mx.length === 1) return mx[0];
            if (mx.length === 2) return mx[1];
            return mx.slice(1);

        case '=': // ["=", name, idx]
            var idx = op[2];
            var rule = code[idx];
            if (!rule) { // bad grammar ...
                return report("missing rule "+idx+": '"+op[1]+"' ...");
            }
            ruleStack.push(inRule)
            inRule = op[1];
            var start = pos;
            var result = run(rule.code);
            inRule = ruleStack.pop();
            if (result === null) {
                pos = start;
                return null;
            }
            var {name, action} = rule;
            var val = run_action(result, {name, action, pos, input, posit, env:options});
            if (val !== null) return val;
            pos = start; // fail
            return null;

        case ',': // [",", ..., seq, ... ]
            var start = pos;
            var res = [];
            var i = 1;
                while (i < op.length) {
                var temp = run(op[i]);
                if (temp === null) {
                    pos = start;
                    return null;
                }
                res.push(temp);
                i += 1;
            }
            return res;

        case '/': // ["/", ..., alt, ... ]
            var start = pos;
            var res = null; // fail if no alt
            var j = 1;
            while (j < op.length) {
                res = run(op[j]);
                if (res !== null && pos > start) {
                    return res;
                }
                pos = start;
                j += 1;
            }
            return res;

        case '*': // ["*", op]
        var start = pos;
        var temp = run(op[1]);
        if (temp === null) return [];
        var res = [temp];
        while (true) {
            start = pos;
            temp = run(op[1]);
            if (temp === null || pos === start) break;
            res.push(temp);
        }
        return res;

        case '+': // ["+", op]
            var start = pos;
            var temp = run(op[1]);
            if (temp === null) return null;
            var res = [temp];
            while (true) {
                start = pos;
                temp = run(op[1]);
                if (temp === null || pos === start) break;
                res.push(temp);
            }
            return res;

        case '?': // ["?", op]
            var res = run(op[1])
            if (res === null) return "";
            return res;

        case '!': // ["!", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res === null) return "";
            return null;

        case '&': // ["&", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res !== null) return "";
            return null;

        default: // should never happen...
            throw new Error("*** Undefined parse code op: "+JSON.stringify(op));
        }
    } // run

    function report(msg) {
        var [line, col] = line_of(pos);
        var lx = " "+line+"."+col;
        // var at = pos + (maxPos>pos? ".."+maxPos : "") + " of " + input.length;
        //var pre = pos<16? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var pre = line<2? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var show = pre + input.slice(pos,pos+40);
        show = show.replace(/[\x00-\x1f]/g,(c) => {
            if (c === "\n" || c === "r") return "\u00AC";
            if (c === "\t") return "\u2023"
            return "\u00A4";
        })
        // show = show.replace(/[\x00-\x1f]/g,"¬")
        if (input.length > pos+40) show += "..."
        var cursor = "";
        for (var i=0; i < pre.length; i+=1) cursor += " ";
        cursor += "^";
        if (maxPos > pos) {
            var max = maxPos-pos>40? 42 : maxPos;
            for (var i=pos+1; i < max; i+=1) cursor += " ";
            cursor += "^";
        }
        var report;
        if (start_name == "__grit__grammar") {
            report = "*** grammar rule syntax err, line:"+lx+
                    "\n"+show+"\n"+cursor;
        } else {
            report = "*** grammar '"+start_name+"' parse "+msg+
                    "\n'"+maxRule+"' at line:"+lx+
                    "\n"+show+"\n"+cursor;
        };
        if (!options || (!options.silent && !options.console)) {
            throw new Error(report);
        } else if (options.console && !options.silent) {
            console.log(report);
        } else { // silent reporting...
            options.report = report;
        }
        return [null, pos];
    }

    function line_of(pos) {
        let ln = 1, col = 0;
        for (let i = 0; i <= pos; i+=1) {
            const char = input[i];
            if (char === "\n") {
                ln += 1;
                col = 0;
            } else if (char === "\r") { // \r\n?
                if (i < pos && input[i+1] === "\n") i += 1;
                ln += 1;
                col = 0;
            } else col += 1;
        };
        return [ln, col];
    }

    function replay() {
        try {
            parser(code, input, actions, {trace:true});
        } catch(err) {
            // console.log(err);
        }
    }

    function posit(n) {
        // console.log("posit", pos, n);
        pos = n;
    }

    var cache = {};

    function run_action(result, parse) {
        var fn = null;
        var {name, action} = parse; // {name, action, pos, input, posit, env}
        if (action) {
            var ax = action.match(/^\s*(\S+)/);
            act = ax? ax[1] : "";
            fn = actions[act] || std_actions[act];
            if (!fn) { // synthetic action: _x_ etc..
                if (act.match(/^[_x]+$/) && Array.isArray(result)) {
                    var res = [];
                    result.forEach((x, i) => {
                        var k = act[i];
                        if (k === "x") res.push(x);
                    });
                    if (res.length === 1) return res[0];
                    return res;
                } else if (act) { // undefined action name...
                    report(`Missing action: '${act}' for rule: '${name}' ...`);
                }            
            }
        } // action
        const action_function = fn || actions[name] || actions["?"];
        if (action_function) {
            try {
                return action_function(result, parse);
                // return fn(result, {...parse, _:parse, $:parse.cache });
            } catch(err) {
                report("Bad action for '"+name+"':\n"+err);
            }
        }
        return result // [name, result] // default result..
    }


} // parser

// -- built-in semantic actions ---------------------------------------------

const std_actions = {

    yfx: ([x, ys]) => // x (op y)* => [op,x,y]
        ys.reduce((y, [op, z]) => [op, y, z], x),

    xfy: function xfy([x, ys]) {
        if (!ys || ys.length < 1) return x;
        let [[op,y], ...zs] = ys;
        return [op, x, xfy([y, zs])];
    },

    yfy: ([a, bs]) => { // a (op b)* => [a,op,b,op,c,...]
        return bs.reduce((y, b) => y.concat(b), [a])
    },

    xfx: ([a, bs]) => { // a (_ b)* => [a,b,c,...]
        return bs.reduce((y, [_, b]) => y.concat(b), [a]);
    },

    _x: ([_,x]) => x,

    flatten: (xs) => flatten(xs),

    string: (xs) => string(xs),

    number: (xs) => Number(string(xs)),

    x: (result) => result,
    n: (result) => Number(result),
    _: (result) => ""

}

function flatten(xs) {
    return Array.isArray(xs)?
        xs.reduce((y,x) => y.concat(flatten(x)),[]) : xs;
}

function string(xs) {
    return Array.isArray(xs)? flatten(xs).join('') : xs;
}

// == Operator expression function ==============================

function operex(...op_spec) { // => opex parser function

    const opdef = encodeOps(op_spec);

    /* == operator defintions ==
        const opex = operex(
            ["fy", "+", "-"],   // prefix, tightly bound
            ["xfy", "^"],
            ["yfx", "*", "/"],
            ["yfx", "+", "-"],
            ["xfy", "="]         // loosely bound
        );

        The operators are encoded into an op key map: opdef,
        indexed n = 1,3,5,7,..., binding strength, tighest = 1
        binding strengths: [prefix, left, right, suffix]:
            fx =>  [n,0,0,0];
            fy =>  [n+1,0,0,0]; 
            xfx => [0,n,n,0];   // [pfx,left,right,sfx]
            yfx => [0,n+1,n,0];
            xfy => [0,n,n+1,0];
            xf =>  [0,0,0,n];
            yf =>  [0,0,0,n+1];

        opdef = {
            "+": [1,8,7,0],  // fy , yfx
            "-": [1,8,7,0],
            "^": [0,3,4,0],  // xfy left < right
            "*": [0,6,5,0],  // yfx left > right
            ...
        }

        node = [op, left, right]
            left == null => prefix
            right == null => suffix
    */
    const nodePower = (node) => {
        if (!Array.isArray(node)) return 0;   // e.g operad
        let [op, left, right] = node;
        if (!opdef[op]) return 0;             // e.g "()"
        if (!left) return prefixPower(op);
        if (!right) return suffixPower(op);
        return infixRight(op);
    }  
    const prefixPower = (op) => opdef[op][0];
    const infixLeft = (op) => opdef[op][1];
    const infixRight = (op) => opdef[op][2];
    const suffixPower = (op) => opdef[op][3];

    const isPrefix = (op) => opdef[op] && opdef[op][0]>0;
    const isInfix = (op) => opdef[op] && opdef[op][1]>0;
    const isSuffix = (op) => opdef[op] && opdef[op][3]>0;

    const is_fy = (op) => opdef[op][0]%2==0;
    const is_yf = (op) => opdef[op][3]%2==0;

    const isOp = (op) => opdef[op];
    const notOp = (op) => !opdef[op];


    // -- encode operators ---------------------------------------------------

    function encodeOps(ops) {
        const opdef = {};
        ops.map((op, i) => { // eg  op = ["yfx", "+", "-"]
            const n = 2*i+1; // 2,4,6,8,...
            op.slice(1).map((sym) => {
                const defn = opdef[sym] || [0,0,0,0];
                const type = op[0];
                if (type === "fx") defn[0] = n;
                else if (type === "fy") defn[0] = n+1;
                else if (type === "xfx") {defn[1] = n; defn[2] = n; }
                else if (type === "xfy") {defn[1] = n; defn[2] = n+1; }
                else if (type === "yfx") {defn[1] = n+1; defn[2] = n; }
                else if (type === "xf") defn[3] = n;
                else if (type === "yf") defn[3] = n+1;
                opdef[sym] = defn; 
            });
        });
        return opdef;
    }

    const op_type = (op) => { // decode...
        const defn = opdef[op];
        if (!defn) return "undefined";
        var sign = "";
        if (defn[0]>0) sign += defn[0]%2==0? "fx":"fy";
        if (defn[1]>0 && defn[1]==defn[2]) sign += " xfx";
        if (defn[1]<defn[2]) sign += " xfy";
        if (defn[1]>defn[2]) sign += " yfx";
        if (defn[3]>0) sign += defn[0]%2==0? " xf":" yf";
        return sign;
    }


    // -- parser ---------------------------------------------------

    function opex(xs) { // xs = tokens...
        //     console.log("opex",xs);
        var tree=[], pos=0;

        if (xs.length === 0) return "";
        if (xs.length === 1) return xs[0];

        // p=prefix, i=infix, s=suffix, x,y=operands
        // valid:  p* x (s* (i p* y)?)? 
        tree = prefixed(); // tree = p* x

        while (pos < xs.length) { // valid: s* (i p* y)?
            var op = xs[pos++];
            if (isSuffix(op) && (!isInfix(op) || !xs[pos] || isOp(xs[pos]))) {
                tree = insertSuffix(tree, op);
                continue;
            }
            if (!isInfix(op)) { // (i p* y)?
                let msg = `expecting infix operator, found: '${op}' ${op_type(op)}`;
                fault(tree, [op], msg);
            }
            var y = prefixed();
            tree = insertInfix(tree, op, y);
        }
        return tree

        function prefixed() { // p* x => 
            var k = pos;
            while (k<xs.length && isPrefix(xs[k])) k+=1;
            if (isOp(xs[k])) { // p* !x
                let msg = `expecting operand, found: '${xs[k]}' ${op_type(op)}`;
                fault(tree, xs.slice(pos,k+1), msg);
            }
            if (k === pos) return xs[pos++]; // x
            var pfx = xs[pos++];
            var result = [pfx, null, xs[pos++]];
            return prefixChain(result, k);
        }
        function prefixChain(node, k) { // p+ x => p(p(..p(x))..)
            if (pos > k) return node;
            var [pfx1, _, pfx2] = node;
            if (prefixPower(pfx1) > prefixPower(pfx2)) {
                let msg = `prefix conflict: '${pfx1}' ${op_type(pfx1)}, '${pfx2}' ${op_type(pfx2)}`;
                fault(tree, xs.slice(pos-1,pos+1), msg);
            }
            node[2] = prefixChain([pfx2, null, xs[pos++]], k);
            return node;
        }

    } // opex

    const insertInfix = (tree, op, z, m = infixLeft(op)) => {
        let n = nodePower(tree);
        if (n < m || !tree[2]) return [op, tree, z];
        if (isLeaf(tree[2])) {
            tree[2] = [op, tree[2], z];
            return tree;
        }
        if (n > m) {
            tree[2] = insertInfix(tree[2], op, z, m);
            return tree;
        }
        fault(tree, [op, z], `invalid '${op}' ${op_type(op)}`);
    }

    const insertSuffix = (tree, sfx, m = suffixPower(sfx)) => {
        let n = nodePower(tree);
        if (n < m || !tree[2]) return [sfx, tree, null];
        if (isLeaf(tree[2])) {
            tree[2] = [sfx, tree[2], null];
            return tree;
        }
        if (n > m) {
            tree[2] = insertSuffix(tree[2], sfx, m);
            return tree;
        }
        if (n === m && is_yf(sfx)) { // must be yf
            tree[2] = [sfx, tree[2], null];
            return tree;
        }
        fault(tree, [sfx, null], `invalid '${sfx}' ${op_type(sfx)}`);
    }

    const isLeaf = (x) => !x || !Array.isArray(x) || notOp(x[0]);

    const fault = (tree, rest, msg) => {
        const ast = JSON.stringify(tree);
        throw new Error(`Bad op expr: ${msg}\n${ast} ${rest.join(" ")}`);
    }

    return opex;
} // operex
    
// -- grit_parser --------------------------------------------------------

function grit_parser (grammar, actions) {

    let [code, _] = parser(grit_code, grammar, grit_actions)

    if (!code) return null;
    
    resolve_code(code);

    function parse(input, options) {
        const [result, pos] = parser(code, input, this.actions, options);
        this.result = {input, pos, result};
        return result;
    };

    function match(input, options) {
        try {
            var result = this.parse(input, options);
        } catch(err) {
            this.err = err;
            return null;
        }
        return result;
    }

    return {parse, match, grammar, actions, code};
}


// expose grit_parser ----------------------------------------------

grit_parser.operators = operex;

// module.exports = grit_parser;

if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = grit_parser;
} else if (typeof define === 'function' && define.amd) {
    define(function() { return grit_parser; });
} else {
    this.grit_parser = grit_parser;
}

}).call(function() {
return this || (typeof window !== 'undefined' ? window : global);
}()); // outer funtion name-space wrapper
    
    
</script>
<script>
    // window.gritbox -- global variable for gritbox HTML events to use.
    // expects grit-prser in: window.grit_parser, see below (line 33)....
    if (window.gritbox) throw new Error("Browser window.gritbox already in use? ...");
    window.gritbox = {};
    var gritbox = window.gritbox

    gritbox.RESET = (i) => {
	    var src = gritbox.textarea_src(i)
        var example = gritbox.example(i, 0)
	    src.value = example.value
	    gritbox.RUN(i);
    }
    gritbox.RUN = (i) => {
        var src = gritbox.textarea_src(i)
        var dst = gritbox.textarea_dst(i)
        var res = "";
        try {
            var verbs = {
                grit: window.grit_parser, // See above...
                operex: window.operex,
                write: (txt) => res += JSON.stringify(txt)+"\n",
                print: (txt) => res += JSON.stringify(txt, null, 2),
                nl: () => res += "\n"
            }
            var keys = Object.keys(verbs);
            var vals = keys.map((k)=> verbs[k])
            var fn = new Function(...keys, src.value)
            fn(...vals);
        } catch(err) {
            res = err
        }
        dst.value = res;
    }
    gritbox.SELECT = (i) => {
        var x = document.getElementById("gritbox-select-"+i).value;
        var example = gritbox.example(i, x-1)
        var src = gritbox.textarea_src(i)
        src.value = example.value
        gritbox.RUN(i);
    }
    gritbox.textarea_src = (i) => document.getElementById('gritbox-src-'+i);
    gritbox.textarea_dst = (i) => document.getElementById('gritbox-dst-'+i);
    gritbox.example = (i, n) => document.getElementById('gritbox-eg-'+i+'-'+n);
</script>
<style>
textarea {font-family: monospace; font-size:10pt; background:whitesmoke;}
</style>

</head>
<body>
<h1>From Regex to Gritex</h1>
<p>A regular expression, or <em>regex</em>, is a common feature of modern programming languages. A regex is often used for pattern matching in every-day text processing.
</p>
<p>In contrast, grammar rules live in a separate world, they are used for specifications, but only a few programmers use grammar based parsers. They are generally reserved for special projects, such as implementing a parser for a full programming language.
</p>
<p>Grammar rules are more powerful than regular expressions, they can be used to define context-free languages. Most programming languages, domain specific languages, and data formats used in practice can be recognized by a context-free parser.
</p>
<p>The term <em>gritex</em> is introduced here to mean a more general form of <em>regex</em> that can be defined by grammar rules.  As you will see a gritex can be defined just as easily as a regex, and used for pattern matching in every-day programming.
</p>
<p>The following examples are in JavaScript to demonstrate executable program code, but the grammar rules themselves are independent of the host programming language. The <a href='https://github.com/pcanz/grammar-parser/'><code>grit-parser</code></a> is used to run the examples.
</p>

<p>To see how this works, let&rsquo;s start with a simple regular expression:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(1)' >Example 1</button>
    <button onClick='gritbox.RUN(1)'>RUN</button>
  </div>
  <textarea id='gritbox-src-1' style="width:49%" rows=3>const regex = /^(\d{4})-(\d{2})-(\d{2})/;

write( regex.exec("2020-03-04") );</textarea>
  <textarea id='gritbox-dst-1' style="width:49%" rows=3></textarea>
  
      <textarea id='gritbox-eg-1-0' hidden>const regex = /^(\d{4})-(\d{2})-(\d{2})/;

write( regex.exec("2020-03-04") );</textarea>
  <script>gritbox.RUN(1)</script><br>

<p>The regular expression defines a <em>regex</em>, but a <em>gritex</em> object can be created from exactly the same regular expression.
</p>
<p>The gritex object is created using a <code>grit</code> template literal tag function, and offers a <code>parse</code> method rather than the regex <code>exec</code>:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(2)' >Example 2</button>
    <button onClick='gritbox.RUN(2)'>RUN</button>
  </div>
  <textarea id='gritbox-src-2' style="width:49%" rows=3>const gritex = grit`^(\d{4})-(\d{2})-(\d{2})`;

write( gritex.parse("2020-03-04") );</textarea>
  <textarea id='gritbox-dst-2' style="width:49%" rows=3></textarea>
  
      <textarea id='gritbox-eg-2-0' hidden>const gritex = grit`^(\d{4})-(\d{2})-(\d{2})`;

write( gritex.parse("2020-03-04") );</textarea>
  <script>gritbox.RUN(2)</script><br>

<p>The match result is slightly different, but the gritex is a direct alternative to the regex.
</p>
<p>In a grammar rule a regular expression can be pulled apart into separate components:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(3)' >Example 3</button>
    <button onClick='gritbox.RUN(3)'>RUN</button>
  </div>
  <textarea id='gritbox-src-3' style="width:49%" rows=3>const gritex = grit`\d{4} '-' \d{2} '-' \d{2}`;

write( gritex.parse("2020-03-04") );</textarea>
  <textarea id='gritbox-dst-3' style="width:49%" rows=3></textarea>
  
      <textarea id='gritbox-eg-3-0' hidden>const gritex = grit`\d{4} '-' \d{2} '-' \d{2}`;

write( gritex.parse("2020-03-04") );</textarea>
  <script>gritbox.RUN(3)</script><br>

<p>This <em>gritex</em> is defined with a grammar rule that contains five separate components. It matches in the same way as the original <em>regex</em> except that each of its component parts are matched separately.
</p>
<p>The regex capture-group parentheses are not required since each component match returns its own match result. The leading <code>^</code> can be dropped since a gritex always matches the full input from the beginning.
</p>
<p>White-space in the grammar rule is not significant, other than to separate the component parts. But it does mean that a regex component in a grammar rule can not contain a space character, unless it is inside square brackets (as a character in a regex character set).
</p>
<p>In a grammar rule a regex component must start with a square bracket character set, or a backslash regex shorthand character set, or a leading <code>^</code>. To match a literal string component it must be in quotes (or be given a <code>^</code> prefix).
</p>
<p>This grammar rule can be reduced back to a single regular expression, but without capture groups it will be matched as a single component:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(4)' >Example 4</button>
    <button onClick='gritbox.RUN(4)'>RUN</button>
  </div>
  <textarea id='gritbox-src-4' style="width:49%" rows=3>const date = grit`\d{4}-\d{2}-\d{2}`;

write( date.parse("2020-03-04") );</textarea>
  <textarea id='gritbox-dst-4' style="width:49%" rows=3></textarea>
  
      <textarea id='gritbox-eg-4-0' hidden>const date = grit`\d{4}-\d{2}-\d{2}`;

write( date.parse("2020-03-04") );</textarea>
  <script>gritbox.RUN(4)</script><br>

<p>You can edit any of the examples and hit the Run button to try things out, hitting the Example button will restore the original source text. You might try putting back one or more capture groups, or separating out components, to see what happens.
</p>
<p>A grammar typically has more than one rule, and each rule starts with a name. The first rule name is optional, but it is a good practice to name all the rules, even if there is only one:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(5)' >Example 5</button>
    <button onClick='gritbox.RUN(5)'>RUN</button>
  </div>
  <textarea id='gritbox-src-5' style="width:49%" rows=5>const date = grit`
    ymd = \d{4} '-' \d{2} '-' \d{2}
`;

write( date.parse("2020-03-04") );</textarea>
  <textarea id='gritbox-dst-5' style="width:49%" rows=5></textarea>
  
      <textarea id='gritbox-eg-5-0' hidden>const date = grit`
    ymd = \d{4} '-' \d{2} '-' \d{2}
`;

write( date.parse("2020-03-04") );</textarea>
  <script>gritbox.RUN(5)</script><br>

<p>Grammar rule components can name other grammar rules, and this allows the same example to be expressed with named components:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(6)' >Example 6</button>
    <button onClick='gritbox.RUN(6)'>RUN</button>
  </div>
  <textarea id='gritbox-src-6' style="width:49%" rows=8>const date = grit`
    date  = year '-' month '-' day
    year  = \d{4}
    month = \d{2}
    day   = \d{2}
`;

write( date.parse("2020-03-04") );</textarea>
  <textarea id='gritbox-dst-6' style="width:49%" rows=8></textarea>
  
      <textarea id='gritbox-eg-6-0' hidden>const date = grit`
    date  = year '-' month '-' day
    year  = \d{4}
    month = \d{2}
    day   = \d{2}
`;

write( date.parse("2020-03-04") );</textarea>
  <script>gritbox.RUN(6)</script><br>

<p>This grammar defines a gritex that is the just the same as the regex that we started with, but expressed in a different way. This version is easy to read, but more verbose. You may prefer a more succinct regex style grammar rule, it&rsquo;s your choice.
</p>
<p>Large regular expressions are often hard to read and understand, for example:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(7)' >Example 7</button>
    <button onClick='gritbox.RUN(7)'>RUN</button>
  </div>
  <textarea id='gritbox-src-7' style="width:49%" rows=7>const uri = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

var text = "https://host/path/file/foo.txt";

write( uri.exec(text) );

</textarea>
  <textarea id='gritbox-dst-7' style="width:49%" rows=7></textarea>
  
      <textarea id='gritbox-eg-7-0' hidden>const uri = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

var text = "https://host/path/file/foo.txt";

write( uri.exec(text) );

</textarea>
  <script>gritbox.RUN(7)</script><br>

<p>In this case a grammar rule version is far easier to read and understand:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(8)' >Example 8</button>
    <button onClick='gritbox.RUN(8)'>RUN</button>
  </div>
  <textarea id='gritbox-src-8' style="width:49%" rows=12>const uri = grit`
    uri    = scheme? host? path query? frag?
    scheme = [^:/?#]+ ':'
    host   = '//' [^/?#]*
    path   = [^?#]*
    query  = '?' [^#]*
    frag   = '#' [^\s]*
`;

var text = "https://host/path/file/foo.txt";

write( uri.parse(text) );</textarea>
  <textarea id='gritbox-dst-8' style="width:49%" rows=12></textarea>
  
      <textarea id='gritbox-eg-8-0' hidden>const uri = grit`
    uri    = scheme? host? path query? frag?
    scheme = [^:/?#]+ ':'
    host   = '//' [^/?#]*
    path   = [^?#]*
    query  = '?' [^#]*
    frag   = '#' [^\s]*
`;

var text = "https://host/path/file/foo.txt";

write( uri.parse(text) );</textarea>
  <script>gritbox.RUN(8)</script><br>

<p>The grammar rule version has simply split the regex apart into named components. The Grit grammar rule parser can efficiently knit together small regular expression components.
</p>
<p>The grammar rule gritex is doing nothing more than the regex, but the ability to split the regex into smaller named components is a big win.
</p>
<h2>Full Text Match</h2>
<p>The big difference between a regex and a gritex is that a regex is ideal for finding the first match in surrounding text, whereas a gritex insists on matching the full input text.
</p>
<p>For example, to find a date match with a regex:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(9)' >Example 9</button>
    <button onClick='gritbox.RUN(9)'>RUN</button>
  </div>
  <textarea id='gritbox-src-9' style="width:49%" rows=5>const date_regex = /(\d{4})-(\d{2})-(\d{2})/;

const input = "The start is: 2020-03-04."

write( date_regex.exec(input) );</textarea>
  <textarea id='gritbox-dst-9' style="width:49%" rows=5></textarea>
  
      <textarea id='gritbox-eg-9-0' hidden>const date_regex = /(\d{4})-(\d{2})-(\d{2})/;

const input = "The start is: 2020-03-04."

write( date_regex.exec(input) );</textarea>
  <script>gritbox.RUN(9)</script><br>

<p>The regex engine will implicitly try at each character position form the beginning until it finds a match.
</p>
<p>In a gritex this has to be made explicit:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(10)' >Example 10</button>
    <button onClick='gritbox.RUN(10)'>RUN</button>
  </div>
  <textarea id='gritbox-src-10' style="width:49%" rows=7>const date = grit`
    ymd  = ^.*?(\d{4})-(\d{2})-(\d{2}).*
`;

const input = "The start is: 2020-03-04."

write( date.parse(input) );</textarea>
  <textarea id='gritbox-dst-10' style="width:49%" rows=7></textarea>
  
      <textarea id='gritbox-eg-10-0' hidden>const date = grit`
    ymd  = ^.*?(\d{4})-(\d{2})-(\d{2}).*
`;

const input = "The start is: 2020-03-04."

write( date.parse(input) );</textarea>
  <script>gritbox.RUN(10)</script><br>

<p>This works because a grammar rule can use any regular expression, but it is not ideal, a regex is a better fit for this task.
</p>
<p>A grammar must match the full input text, so a grammar to match dates anywhere in the input needs to skip all text other than the date matches.
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(11)' >Example 11</button>
    <button onClick='gritbox.RUN(11)'>RUN</button>
  </div>
  <textarea id='gritbox-src-11' style="width:49%" rows=16>const date = grit`
    find = date*
    date = \D* ymd? \d*
    ymd  = \d{4} '-' \d{2} '-' \d{2}
`;
date.actions = {
    date: ([_,ymd,__]) => ymd,
    ymd:  ([y,_,m,__,d]) => [y,m,d]
}

const input = `
    It starts: 2020-03-04,
    and ends: 2020-05-06.
`;

write( date.parse(input) );</textarea>
  <textarea id='gritbox-dst-11' style="width:49%" rows=16></textarea>
  
      <textarea id='gritbox-eg-11-0' hidden>const date = grit`
    find = date*
    date = \D* ymd? \d*
    ymd  = \d{4} '-' \d{2} '-' \d{2}
`;
date.actions = {
    date: ([_,ymd,__]) => ymd,
    ymd:  ([y,_,m,__,d]) => [y,m,d]
}

const input = `
    It starts: 2020-03-04,
    and ends: 2020-05-06.
`;

write( date.parse(input) );</textarea>
  <script>gritbox.RUN(11)</script><br>

<p>The semantic action functions provide a convenient way to simplify the results so that only the date matches are returned.
</p>
<p>Using a regex is an easier way to find a single match. But a gritex can find multiple matches, and that is a more difficult task for a regex.
</p>
<h2>Repeating Matches</h2>
<p>A regular expression match only returns the last match of a capture-group, so a repeated regex can not be used to return individual matches for multiple items. 
</p>
<p>For example, this regex will match words in a list, but repeated matches will only report the last word matched:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(12)' >Example 12</button>
    <button onClick='gritbox.RUN(12)'>RUN</button>
  </div>
  <textarea id='gritbox-src-12' style="width:49%" rows=3>const list = /(\s*(\w+))*/;

write( list.exec("abc def ghi") );</textarea>
  <textarea id='gritbox-dst-12' style="width:49%" rows=3></textarea>
  
      <textarea id='gritbox-eg-12-0' hidden>const list = /(\s*(\w+))*/;

write( list.exec("abc def ghi") );</textarea>
  <script>gritbox.RUN(12)</script><br>

<p>Using a string <code>match</code> with a regex plus a global flag will return all matches, but not any capture groups. JavaScript ES 2020 has introduced a <code>matchAll</code> to help, but in general program code is needed to iterate a regex match.
</p>
<p>A grammar rule version defines a gritex that does not have this problem, all the list items are individually matched:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(13)' >Example 13</button>
    <button onClick='gritbox.RUN(13)'>RUN</button>
  </div>
  <textarea id='gritbox-src-13' style="width:49%" rows=3>const list = grit`(\s*(\w+))*`;

write( list.parse("abc def ghi") );</textarea>
  <textarea id='gritbox-dst-13' style="width:49%" rows=3></textarea>
  
      <textarea id='gritbox-eg-13-0' hidden>const list = grit`(\s*(\w+))*`;

write( list.parse("abc def ghi") );</textarea>
  <script>gritbox.RUN(13)</script><br>

<p>Or spelling the same thing out a bit more:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(14)' >Example 14</button>
    <button onClick='gritbox.RUN(14)'>RUN</button>
  </div>
  <textarea id='gritbox-src-14' style="width:49%" rows=6>const list = grit`
    list = item*
    item = \s* \w+
`;

write( list.parse("abc def ghi") );</textarea>
  <textarea id='gritbox-dst-14' style="width:49%" rows=6></textarea>
  
      <textarea id='gritbox-eg-14-0' hidden>const list = grit`
    list = item*
    item = \s* \w+
`;

write( list.parse("abc def ghi") );</textarea>
  <script>gritbox.RUN(14)</script><br>

<p>Traditional grammar based parsers use a pre-processor, sometimes called a lexer, that can use regular expressions to break the input text into a list of tokens. But a Grit grammar can integrate the lexer token matching into the grammar rules.
</p>
<p>Here is a simple lexer that will match words or symbols and skip white-space:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(15)' >Example 15</button>
    <button onClick='gritbox.RUN(15)'>RUN</button>
  </div>
  <textarea id='gritbox-src-15' style="width:49%" rows=9>const lexer = grit`
    lex     = token*
    token   = int / var / symbol
    int     = \s*(\d+)
    var     = \s*(\w+)
    symbol  = \s*([^ \w]+)
`;

write( lexer.parse("x = a+2*b") );</textarea>
  <textarea id='gritbox-dst-15' style="width:49%" rows=9></textarea>
  
      <textarea id='gritbox-eg-15-0' hidden>const lexer = grit`
    lex     = token*
    token   = int / var / symbol
    int     = \s*(\d+)
    var     = \s*(\w+)
    symbol  = \s*([^ \w]+)
`;

write( lexer.parse("x = a+2*b") );</textarea>
  <script>gritbox.RUN(15)</script><br>

<p>Notice that the digits in an <code>int</code> can also be matched by the regex word <code>\w</code> shorthand, so the <code>int</code> must be matched first, before the <code>var</code>. The <code>/</code> choice operator only returns the <em>first</em> match (there is no ambiguity, choice rules do not backtrack).
</p>
<p>This grammar defines a gritex that can be run as a parser. It uses named regex expressions, knitted together in sequence, or as alternatives with the <code>/</code> choice operator. The grammar rules follow the formal logic of a <a href='https://en.wikipedia.org/wiki/Parsing_expression_grammar'>PEG</a> (Parser Expression Grammar).
</p>

<p>The tokens here are simply the matched strings, but a real lexer would probably generate objects with a type, a value, and other information. A Grit grammar could use semantic action functions to generate token objects, but our focus here is on using a gritex as an alternative to a regex.
</p>
<h2>Grammar Specifications</h2>
<p>Grammars are not often used in program code, but they are often used in specifications to define what the program code should do.
</p>
<p>For example, here is a fragment of the <a href='https://www.json.org/json-en.html'>JSON specification</a> that defines numbers:
</p>
<pre class="code"><code>number
    integer fraction exponent
integer
    digit
    onenine digits
    '-' digit
    '-' onenine digit
digits
    digit
    digit digits
digit
    '0'
    onenine
onenine
    '1' . '9'
fraction
    ""
    '.' digits
exponent
    ""
    'E' sign digits
    'e' sign digits
sign
    ""
    '+'
    '-'</code></pre>

<p>Translating this directly into a Grit grammar we get:
</p>
<pre class="code"><code>number   = integer fraction? exponent?
integer  = '-'? ('0' / [1-9][0-9]*)
fraction = '.' [0-9]+
exponent = [eE][+-]?[0-9]+</code></pre>
<p>Translated into a regex:
</p>
<pre class="code"><code>num_regex = /^-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?/</code></pre>
<p>The formal grammar specification is clear and easy to understand with minimal syntax, but rather verbose. The Grit grammar requires more syntax, but it is almost as easy to read and understand, and it is nice and concise. The regex is simply too cryptic, although many programmers would find it easy enough to read and understand.
</p>
<p>The Grit grammar rules are a compromise between the clarity of a formal specification, and the automated efficiency of a regular expression.  There is an art to the design of good grammar rules that are both easy to understand, and easy to execute as an efficient parser.
</p>
<h2>Context-free Grammars</h2>
<p>Nested expressions are beyond the power of a regular expression, a context-free grammar is required.
</p>
<p>For example, here is a very basic grammar for balanced parentheses:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(16)' >Example 16</button>
    <button onClick='gritbox.RUN(16)'>RUN</button>
  </div>
  <textarea id='gritbox-src-16' style="width:49%" rows=8>const paren = grit`
    p = '(' (p/q)* ')'
    q = [^()]*
`;

const text = `(x((y)z))`;

write(paren.parse(text));</textarea>
  <textarea id='gritbox-dst-16' style="width:49%" rows=8></textarea>
  
      <textarea id='gritbox-eg-16-0' hidden>const paren = grit`
    p = '(' (p/q)* ')'
    q = [^()]*
`;

const text = `(x((y)z))`;

write(paren.parse(text));</textarea>
  <script>gritbox.RUN(16)</script><br>

<p>The regular expression <code>q</code> matches any characters other than parentheses, and <code>p</code> matches any number of <code>p</code> or <code>q</code> terms inside a pair of parentheses.
</p>
<p>This is more than a regular expression because a <code>p</code> rule can be nested inside an outer <code>p</code> by calling itself recursively. 
</p>
<p>Here is a more realistic grammar for nested expressions:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(17)' >Example 17</button>
    <button onClick='gritbox.RUN(17)'>RUN</button>
  </div>
  <textarea id='gritbox-src-17' style="width:49%" rows=10>const expr = grit`
    expr   = term*
    term   = token / "(" expr ")"
    token  = int / var / symbol
    int    = \s*(\d+)
    var    = \s*(\w+)
    symbol = \s*([^ ()\w]+)
`;

write( expr.parse("x = (a+(2*b))+c") );</textarea>
  <textarea id='gritbox-dst-17' style="width:49%" rows=10></textarea>
  
      <textarea id='gritbox-eg-17-0' hidden>const expr = grit`
    expr   = term*
    term   = token / "(" expr ")"
    token  = int / var / symbol
    int    = \s*(\d+)
    var    = \s*(\w+)
    symbol = \s*([^ ()\w]+)
`;

write( expr.parse("x = (a+(2*b))+c") );</textarea>
  <script>gritbox.RUN(17)</script><br>

<p>The grammar is easy enough to read, it says that an <code>expr</code> is any number of terms, <code>term*</code>, and a <code>term</code> is either a <code>token</code> or a nested <code>expr</code> inside parentheses.
</p>
<p>The only grammar rule components that match any input are quoted literal strings or named regular expressions, the trick is that the rule names allow recursion, which enables matching of nested expressions.
</p>
<h1>Conclusion</h1>
<p>Starting with a regular expression we have seen how a grammar rule is just another way to do the same thing. A grammar with a single rule can be used to match input text is exactly the same way as a regex.
</p>
<p>This enables grammar rules to define a <em>gritex</em> that can be used in every-day programming just as easily as a <em>regex</em>.
</p>
<p>Grammar rules allow a regular expressions to be broken out into smaller components, in separate named rules, which makes larger regular expressions much easier to read.
</p>
<p>Grammar rules are a better alternative simply because they can express a regex in a better way. Large regular expressions are far too cryptic.
</p>
<p>Grammar rules also enable a regex to be used to match a sequence of terms, without any extra program code. To use a regex to generate a list of match results usually requires program code to iterate the regex through the input.
</p>
<p>Finally we allowed the grammar rules to call each other recursively, and this moves beyond regular expression matching into the world of context-free grammar matching. Almost all practical programming languages and data structures can be parsed with a context-free grammar.
</p>
<p>We have not discussed it here, but a Grit grammar can also use semantic action functions to process rule results, and this provides an escape hatch to even go beyond context-free grammars. The full programming language power is available. This is useful (and occasionally essential) to cope with an odd language feature that can not be expressed with context-free grammar rules.
</p>
<p>Grammar rules can define a <em>gritex</em> that is just as easy to use as a <em>regex</em>, but far more powerful.
</p>


</body>
</html>
