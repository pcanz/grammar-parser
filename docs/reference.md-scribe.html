<!DOCTYPE HTML>
<html>
<head>
<meta lang=en charset="UTF-8">
<style>
body {
    font-family: 'Helvetica Neue', Helvetica, Arial, serif;
    font-size: 1em; line-height: 1.5; color: #505050;
}
.code { background: whitesmoke; margin:0pt 10pt;}
blockquote {border-left: solid thick gainsboro; padding-left:5pt;}
h1,h2,h3,h4 {border-bottom: thin solid gainsboro; }
.key-val { margin:0px; }
.key-val-blk { margin:0px; margin-left:20pt; }
[data-tight='false'] > li {margin-bottom:12pt;}
q { quotes: "“" "”" "‘" "’"; }

</style>
<script>
// grit-parser loads itself into: window.grit_parser
// Grammar Parser -- an evolution of Grit.

// See docs at: https://github.com/pcanz/grammar-parser

/*	The MIT License (MIT)
 *
 *	Copyright (c) 2015,2016,2017,2018,2019 Peter Cashin
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files(the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 *	furnished to do so, subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included
 *	in all copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 *	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

;(function() { // module name-space wrapper -- see the end of this file...

/* -- grammar-rule grammar ---------------------------------------

    grammar = rule+
    rule    = name "=" expr ws act?

    expr    = seq ("/" seq)*
    seq     = (ws [&!]? term [*+?]?)*
    term    = ref / quote / regex / group

    name    = ws \w+
    ref     = name !\s*=
    group   = "(" expr ")"

    quote   = '"' [^"]* '"' / "'" [^']* "'"
    regex   = &[[\\^] (chs / par / misc)+
    chs     = [\[] ([^\]\\]* ([\\][^])?)+ [\]]
    par     = [(] ([^()]* par?)* [)]
    misc    = [^[()\s]+

    act     = ":" lines
    lines   = line (\s* !\S+\s*= line)*
    line    = [^\n\r]* 
    ws      = \s*  
*/

// -- parser code for grit_rules --------------------------------------

// The parser is a byte-code style interpreter, but encodes
// instructions an array data structure with string values.

/* parser instruction codes:

    ["^", "regex"]      match regexp
    ["=", rule]         call rule by name.
    [",", a, b, c, ...] sequence of instruction codes, all to succeed.
    ["/", a, b, c, ...] alternatives, first to succeed.
    ["+", x]            matches one or more x, or fails.
    ["*", x]            matches any number of x, none matches "".
    ["?", x]            optional match: x / ""
    ["&", x]            lookahead: "" if x matches, else fails.
    ["!", x]            negation: fails if x matches, else "".
    
    The parser compiles rule names to rule indexes on the fly, and also
    compiles regexp's on the fly (to keep the code simple, and portable).

    The parser code can be exported as JSON.
*/

const grit_code = [
    {   name: "__grit__grammar", // grammar = rule+
        code: ["+",["=","rule"]] },

    {   name: "rule", // rule = name "=" expr ws act?
        code: [",",["=","name"],["^","\\s*="],["=","expr"],
                        ["=", "ws"],["?",["=","act"]]] },

    {   name: "expr", // expr = seq ("/" seq)*
        code: [",",["=","seq"],["*",[",",["^","\\s*/"],["=","seq"]]]] },

    {   // seq = (ws [&!]? term [*+?]?)*
        name: "seq",
        code: ["*",[",",["=","ws"],["^","[&!]?"],["=","term"],["^","[*+?]?"]]] },

    {   name: "term", // term = ref / quote/ regex / group
        code: ["/",["=","ref"],["=","quote"],["=","regex"],["=","group"]] },

    {   name: "name", // name = ws \w+
        code: [",",["^","[\\s]*"],["^","[\\w]+"]] },

    {   name: "ref", // ref = name !\s*=
        code: [",",["=","name"],["!",["^","[\\s]*="]]] },

    {   name: "quote", // quote = '"' [^"]* '"' / "'" [^']* "'"
        code: ["^","\\s*((?:'[^']*'|\"[^\"]*\")[\\w]*)"] },

    {   name: "regex", // regex = &[[\\^] (chs / par / misc)+
        code: [",",["&",["^","[[\\\\^]"]],["+",["/",["=","chs"],["=","par"],["=","misc"]]]] },

    {   name: "chs", // [\[] ([^\]\\]* ([\\][^])?)+ [\]]
        code: ["^","[[](?:[^\\]\\\\]*(?:[\\\\][^])?)+[\\]]"] },

    {   name: "par", // par = [(] ([^()]* par?)* [)]
        code: [",",["^","[(]"],["*",[",",["^","[^()]*"],["?",["=","par"]]]],["^","[)]"]] },

    {   name: "misc", // [^[()\s]+
        code: ["^","[^[()\\s]+"] },

    {   name: "group", // group = "(" expr ")"
        code: [",",["^","\\s*\\("],["=","expr"],["^","\\s*\\)"]] },

    {   name: "act", // act = ":" lines
        code: [",",["^","\\s*:"],["^","[^\\n\\r]*"], // line = [^\n\r]*
                ["*",[",",["^","\\s*"],["!",["^","\\S+\\s*="]],
                            ["^","[^\\n\\r]*"]]]] },

    {   name: "ws", // ws = \s* 
        code: ["^","\\s*"] }
];

resolve_code(grit_code); // maps names to indexes & compiles regexes

// -- compile peg rules into parser instruction codes --------------------

const grit_actions = { // semantic actions for parse tree nodes...

    // grammar = rule+
    "grammar": (rs) => rs,

    // rule = name "=" expr ws act?
    "rule": ([name, _, code, ws, action]) => {
        return {name, code, action};
    },

    // expr = seq ("/" seq)*
    "expr": ([seq, alts]) => {
        if (alts.length === 0) {
            return seq;
        } else {
            var seqs = alts.map(([_, seq]) => seq)
            return ["/", seq, ...seqs];
        }
    },

    // seq = (ws [&!]? term [*+?]?)*
    "seq": (xs) => {
        var ts = xs.map(([ws, pred, term, rep]) => {
            if (rep) { term = [rep, term]; }
            if (pred) { term = [pred, term];}
            return term;
        })
        if (ts.length === 1) return ts[0];
        return [",", ...ts];
    },

    // term = ref / match / group
    "term": (x) => x,

    // name = ws \w+
    "name": ([_, name]) => name,

    // ref = name !\s*=
    "ref":  ([name, _]) => ["=", name, null],

    // group = "(" expr ")"
    "group": ([_, expr]) => expr,

    // quote = '"' [^"]* '"' / "'" [^']* "'"
    "quote": (str) => { // quote => regex: \s*("...")\s*
        if (str.length === 2) { // empty quotes..
            return (str[0] === "'")? ["^","\uFFFF?"] : ["^","\\s*(\uFFFF?)"];
        }
        qt = str.slice(1,-1);
        if (str[0] === "'") return ["^",esc_regex(qt)];
        return ["^","\\s*("+esc_regex(qt)+")\\s*"];
    },

    // // regex   = &[[\\^] (chs / par / misc)*
    // "regex": ([_, rs]) => rs[0]==='^'? 
    //             ["^", rs.slice(1).join('')] : ["^", rs.join('')],

    // regex   = &[[\\^] (chs / par / misc)*
    "regex": ([_, rs]) => rs[0] && rs[0][0]==='^'? 
                ["^", rs[0].slice(1)+rs.slice(1).join('')]
                : ["^", rs.join('')],

    // par = [(] ([^()]* par?)* [)]
    "par": ([lp, ps, rp]) => { // par? => p, will be already done..
        var xps = ps.map(([x, p]) => p? x+p : x);
        return lp + xps.join('') + rp; 
    },

    // act = ":" lines
    "act": ([_, line, lines]) => {
        return string([line, lines]);
    },

    // ws = \s*
    "ws": (s) => s

} // grit_actions

function esc_regex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function rules_map(code) {
    return code.reduce((rm, rule, idx) => {
        rm[rule.name] = idx; return rm; }, {});
}

function resolve_code(code) {
    var name_idx = rules_map(code);

    function resolve (op) {
        if (!Array.isArray(op)) return op;
        if (op[0] === "^") {
            op[2] = op[2] || new RegExp(op[1],"yus"); // sticky unicode dots flags
            return op;
        }
        if (op[0] === "=") {
            op[2] = name_idx[op[1]];
            if (!op[2] && op[2]!==0) {
                throw new Error("*** missing rule '"+op[1]+"' ... ")
            }
            return op;
        }
        return op.map((x) => resolve(x));
    }
    var coded = code.map((rule) => {
        return resolve(rule.code);
    });

    return code;
}
    
// -- parser -- string-code interpreter ------------------------------------

const ANON = "__anon__"; // default name for first rule

function parser (code, input, actions={}, options={}) {
    var pos = 0;
    var inRule = "start"; // current rule trace 
    var ruleStack = [];
    var maxPos = 0; // high water mark
    var maxRule= ""; // inRule at maxPos
    var runOps = 0;
    var maxOps = 10000; // run away recursion check

    if (!code) {
        return report("missing grammar rule code...");
    }

    var start_name = code[0].name;
    var start = ["=", start_name, 0];

    if (typeof input !== "string") {
        try { // tag`grammar..` => tag([grammar...], ${}...)
            input = String.raw(input);
            if (!input.match(/^\s*\S+\s*=/)) {
                input = ANON+" = "+input; // simple regex grammar
            }
        } catch(err) {
            input = '';
            return report("input is not a string...");
        }
    }

    if (typeof actions === 'function') {
        actions = { "?": actions } // catch all
    }

    if (options.trace) console.log("trace", start_name)

    var result = run(start); // run the parser engine...

    if (result === null) {
        return report("failed");
    }
    if (pos < input.length && !input.slice(pos).match(/^\s+$/)) {
        if (options.replay) replay();
        return report("fell short");
    }
    return [result, pos];

    // -- code engine -------------------------------------------

    function run(op) {

        if (runOps += 1 > maxOps) {
            return report("run away recursion...");
        }

        switch (op[0]) {

        case '^': // ["^", src, regex]
            var regex = op[2]; 
            regex.lastIndex = pos; // using regex.y sticky flag
            var mx = regex.exec(input);
            var trace = options.trace;
            if (trace) {
                if (typeof trace !== "string" || trace === inRule) {
                    var span = pos;
                    span += mx? ".."+(pos+mx[0].length) : ""
                    var match = mx? "=>"+mx[0] : "!";
                    console.log(span,inRule,regex,match);
                }
            }
            if (!mx) return null;
            pos += mx[0].length;
            if (pos > maxPos) { 
                maxPos = pos; 
                maxRule = inRule;
            }
            // return mx[1]||mx[0]; // used to skip white-space prefix
            if (mx.length === 1) return mx[0];
            if (mx.length === 2) return mx[1];
            return mx.slice(1);

        case '=': // ["=", name, idx]
            var idx = op[2];
            var rule = code[idx];
            if (!rule) { // bad grammar ...
                return report("missing rule "+idx+": '"+op[1]+"' ...");
            }
            ruleStack.push(inRule)
            inRule = op[1];
            var start = pos;
            var result = run(rule.code);
            inRule = ruleStack.pop();
            if (result === null) {
                pos = start;
                return null;
            }
            var {name, action} = rule;
            var val = run_action(result, {name, action, pos, input, posit, env:options});
            if (val !== null) return val;
            pos = start; // fail
            return null;

        case ',': // [",", ..., seq, ... ]
            var start = pos;
            var res = [];
            var i = 1;
                while (i < op.length) {
                var temp = run(op[i]);
                if (temp === null) {
                    pos = start;
                    return null;
                }
                res.push(temp);
                i += 1;
            }
            return res;

        case '/': // ["/", ..., alt, ... ]
            var start = pos;
            var res = null; // fail if no alt
            var j = 1;
            while (j < op.length) {
                res = run(op[j]);
                if (res !== null && pos > start) {
                    return res;
                }
                pos = start;
                j += 1;
            }
            return res;

        case '*': // ["*", op]
        var start = pos;
        var temp = run(op[1]);
        if (temp === null) return [];
        var res = [temp];
        while (true) {
            start = pos;
            temp = run(op[1]);
            if (temp === null || pos === start) break;
            res.push(temp);
        }
        return res;

        case '+': // ["+", op]
            var start = pos;
            var temp = run(op[1]);
            if (temp === null) return null;
            var res = [temp];
            while (true) {
                start = pos;
                temp = run(op[1]);
                if (temp === null || pos === start) break;
                res.push(temp);
            }
            return res;

        case '?': // ["?", op]
            var res = run(op[1])
            if (res === null) return "";
            return res;

        case '!': // ["!", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res === null) return "";
            return null;

        case '&': // ["&", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res !== null) return "";
            return null;

        default: // should never happen...
            throw new Error("*** Undefined parse code op: "+JSON.stringify(op));
        }
    } // run

    function report(msg) {
        var [line, col] = line_of(pos);
        var lx = " "+line+"."+col;
        // var at = pos + (maxPos>pos? ".."+maxPos : "") + " of " + input.length;
        //var pre = pos<16? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var pre = line<2? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var show = pre + input.slice(pos,pos+40);
        show = show.replace(/[\x00-\x1f]/g,(c) => {
            if (c === "\n" || c === "r") return "\u00AC";
            if (c === "\t") return "\u2023"
            return "\u00A4";
        })
        // show = show.replace(/[\x00-\x1f]/g,"¬")
        if (input.length > pos+40) show += "..."
        var cursor = "";
        for (var i=0; i < pre.length; i+=1) cursor += " ";
        cursor += "^";
        if (maxPos > pos) {
            var max = maxPos-pos>40? 42 : maxPos;
            for (var i=pos+1; i < max; i+=1) cursor += " ";
            cursor += "^";
        }
        var report;
        if (start_name == "__grit__grammar") {
            report = "*** grammar rule syntax err, line:"+lx+
                    "\n"+show+"\n"+cursor;
        } else {
            report = "*** grammar '"+start_name+"' parse "+msg+
                    "\n'"+maxRule+"' at line:"+lx+
                    "\n"+show+"\n"+cursor;
        };
        if (!options || (!options.silent && !options.console)) {
            throw new Error(report);
        } else if (options.console && !options.silent) {
            console.log(report);
        } else { // silent reporting...
            options.report = report;
        }
        return [null, pos];
    }

    function line_of(pos) {
        let ln = 1, col = 0;
        for (let i = 0; i <= pos; i+=1) {
            const char = input[i];
            if (char === "\n") {
                ln += 1;
                col = 0;
            } else if (char === "\r") { // \r\n?
                if (i < pos && input[i+1] === "\n") i += 1;
                ln += 1;
                col = 0;
            } else col += 1;
        };
        return [ln, col];
    }

    function replay() {
        try {
            parser(code, input, actions, {trace:true});
        } catch(err) {
            // console.log(err);
        }
    }

    function posit(n) {
        // console.log("posit", pos, n);
        pos = n;
    }

    var cache = {};

    function run_action(result, parse) {
        var fn = null;
        var {name, action} = parse; // {name, action, pos, input, posit, env}
        if (action) {
            var ax = action.match(/^\s*(\S+)/);
            act = ax? ax[1] : "";
            fn = actions[act] || std_actions[act];
            if (!fn) { // synthetic action: _x_ etc..
                if (act.match(/^[_x]+$/) && Array.isArray(result)) {
                    var res = [];
                    result.forEach((x, i) => {
                        var k = act[i];
                        if (k === "x") res.push(x);
                    });
                    if (res.length === 1) return res[0];
                    return res;
                } else if (act) { // undefined action name...
                    report(`Missing action: '${act}' for rule: '${name}' ...`);
                }            
            }
        } // action
        const action_function = fn || actions[name] || actions["?"];
        if (action_function) {
            try {
                return action_function(result, parse);
                // return fn(result, {...parse, _:parse, $:parse.cache });
            } catch(err) {
                report("Bad action for '"+name+"':\n"+err);
            }
        }
        return result // [name, result] // default result..
    }


} // parser

// -- built-in semantic actions ---------------------------------------------

const std_actions = {

    yfx: ([x, ys]) => // x (op y)* => [op,x,y]
        ys.reduce((y, [op, z]) => [op, y, z], x),

    xfy: function xfy([x, ys]) {
        if (!ys || ys.length < 1) return x;
        let [[op,y], ...zs] = ys;
        return [op, x, xfy([y, zs])];
    },

    yfy: ([a, bs]) => { // a (op b)* => [a,op,b,op,c,...]
        return bs.reduce((y, b) => y.concat(b), [a])
    },

    xfx: ([a, bs]) => { // a (_ b)* => [a,b,c,...]
        return bs.reduce((y, [_, b]) => y.concat(b), [a]);
    },

    _x: ([_,x]) => x,

    flatten: (xs) => flatten(xs),

    string: (xs) => string(xs),

    number: (xs) => Number(string(xs)),

    x: (result) => result,
    n: (result) => Number(result),
    _: (result) => ""

}

function flatten(xs) {
    return Array.isArray(xs)?
        xs.reduce((y,x) => y.concat(flatten(x)),[]) : xs;
}

function string(xs) {
    return Array.isArray(xs)? flatten(xs).join('') : xs;
}

// == Operator expression function ==============================

function operex(...op_spec) { // => opex parser function

    const opdef = encodeOps(op_spec);

    /* == operator defintions ==
        const opex = operex(
            ["fy", "+", "-"],   // prefix, tightly bound
            ["xfy", "^"],
            ["yfx", "*", "/"],
            ["yfx", "+", "-"],
            ["xfy", "="]         // loosely bound
        );

        The operators are encoded into an op key map: opdef,
        indexed n = 1,3,5,7,..., binding strength, tighest = 1
        binding strengths: [prefix, left, right, suffix]:
            fx =>  [n,0,0,0];
            fy =>  [n+1,0,0,0]; 
            xfx => [0,n,n,0];   // [pfx,left,right,sfx]
            yfx => [0,n+1,n,0];
            xfy => [0,n,n+1,0];
            xf =>  [0,0,0,n];
            yf =>  [0,0,0,n+1];

        opdef = {
            "+": [1,8,7,0],  // fy , yfx
            "-": [1,8,7,0],
            "^": [0,3,4,0],  // xfy left < right
            "*": [0,6,5,0],  // yfx left > right
            ...
        }

        node = [op, left, right]
            left == null => prefix
            right == null => suffix
    */
    const nodePower = (node) => {
        if (!Array.isArray(node)) return 0;   // e.g operad
        let [op, left, right] = node;
        if (!opdef[op]) return 0;             // e.g "()"
        if (!left) return prefixPower(op);
        if (!right) return suffixPower(op);
        return infixRight(op);
    }  
    const prefixPower = (op) => opdef[op][0];
    const infixLeft = (op) => opdef[op][1];
    const infixRight = (op) => opdef[op][2];
    const suffixPower = (op) => opdef[op][3];

    const isPrefix = (op) => opdef[op] && opdef[op][0]>0;
    const isInfix = (op) => opdef[op] && opdef[op][1]>0;
    const isSuffix = (op) => opdef[op] && opdef[op][3]>0;

    const is_fy = (op) => opdef[op][0]%2==0;
    const is_yf = (op) => opdef[op][3]%2==0;

    const isOp = (op) => opdef[op];
    const notOp = (op) => !opdef[op];


    // -- encode operators ---------------------------------------------------

    function encodeOps(ops) {
        const opdef = {};
        ops.map((op, i) => { // eg  op = ["yfx", "+", "-"]
            const n = 2*i+1; // 2,4,6,8,...
            op.slice(1).map((sym) => {
                const defn = opdef[sym] || [0,0,0,0];
                const type = op[0];
                if (type === "fx") defn[0] = n;
                else if (type === "fy") defn[0] = n+1;
                else if (type === "xfx") {defn[1] = n; defn[2] = n; }
                else if (type === "xfy") {defn[1] = n; defn[2] = n+1; }
                else if (type === "yfx") {defn[1] = n+1; defn[2] = n; }
                else if (type === "xf") defn[3] = n;
                else if (type === "yf") defn[3] = n+1;
                opdef[sym] = defn; 
            });
        });
        return opdef;
    }

    const op_type = (op) => { // decode...
        const defn = opdef[op];
        if (!defn) return "undefined";
        var sign = "";
        if (defn[0]>0) sign += defn[0]%2==0? "fx":"fy";
        if (defn[1]>0 && defn[1]==defn[2]) sign += " xfx";
        if (defn[1]<defn[2]) sign += " xfy";
        if (defn[1]>defn[2]) sign += " yfx";
        if (defn[3]>0) sign += defn[0]%2==0? " xf":" yf";
        return sign;
    }


    // -- parser ---------------------------------------------------

    function opex(xs) { // xs = tokens...
        //     console.log("opex",xs);
        var tree=[], pos=0;

        if (xs.length === 0) return "";
        if (xs.length === 1) return xs[0];

        // p=prefix, i=infix, s=suffix, x,y=operands
        // valid:  p* x (s* (i p* y)?)? 
        tree = prefixed(); // tree = p* x

        while (pos < xs.length) { // valid: s* (i p* y)?
            var op = xs[pos++];
            if (isSuffix(op) && (!isInfix(op) || !xs[pos] || isOp(xs[pos]))) {
                tree = insertSuffix(tree, op);
                continue;
            }
            if (!isInfix(op)) { // (i p* y)?
                let msg = `expecting infix operator, found: '${op}' ${op_type(op)}`;
                fault(tree, [op], msg);
            }
            var y = prefixed();
            tree = insertInfix(tree, op, y);
        }
        return tree

        function prefixed() { // p* x => 
            var k = pos;
            while (k<xs.length && isPrefix(xs[k])) k+=1;
            if (isOp(xs[k])) { // p* !x
                let msg = `expecting operand, found: '${xs[k]}' ${op_type(op)}`;
                fault(tree, xs.slice(pos,k+1), msg);
            }
            if (k === pos) return xs[pos++]; // x
            var pfx = xs[pos++];
            var result = [pfx, null, xs[pos++]];
            return prefixChain(result, k);
        }
        function prefixChain(node, k) { // p+ x => p(p(..p(x))..)
            if (pos > k) return node;
            var [pfx1, _, pfx2] = node;
            if (prefixPower(pfx1) > prefixPower(pfx2)) {
                let msg = `prefix conflict: '${pfx1}' ${op_type(pfx1)}, '${pfx2}' ${op_type(pfx2)}`;
                fault(tree, xs.slice(pos-1,pos+1), msg);
            }
            node[2] = prefixChain([pfx2, null, xs[pos++]], k);
            return node;
        }

    } // opex

    const insertInfix = (tree, op, z, m = infixLeft(op)) => {
        let n = nodePower(tree);
        if (n < m || !tree[2]) return [op, tree, z];
        if (isLeaf(tree[2])) {
            tree[2] = [op, tree[2], z];
            return tree;
        }
        if (n > m) {
            tree[2] = insertInfix(tree[2], op, z, m);
            return tree;
        }
        fault(tree, [op, z], `invalid '${op}' ${op_type(op)}`);
    }

    const insertSuffix = (tree, sfx, m = suffixPower(sfx)) => {
        let n = nodePower(tree);
        if (n < m || !tree[2]) return [sfx, tree, null];
        if (isLeaf(tree[2])) {
            tree[2] = [sfx, tree[2], null];
            return tree;
        }
        if (n > m) {
            tree[2] = insertSuffix(tree[2], sfx, m);
            return tree;
        }
        if (n === m && is_yf(sfx)) { // must be yf
            tree[2] = [sfx, tree[2], null];
            return tree;
        }
        fault(tree, [sfx, null], `invalid '${sfx}' ${op_type(sfx)}`);
    }

    const isLeaf = (x) => !x || !Array.isArray(x) || notOp(x[0]);

    const fault = (tree, rest, msg) => {
        const ast = JSON.stringify(tree);
        throw new Error(`Bad op expr: ${msg}\n${ast} ${rest.join(" ")}`);
    }

    return opex;
} // operex
    
// -- grit_parser --------------------------------------------------------

function grit_parser (grammar, actions) {

    let [code, _] = parser(grit_code, grammar, grit_actions)

    if (!code) return null;
    
    resolve_code(code);

    function parse(input, options) {
        const [result, pos] = parser(code, input, this.actions, options);
        this.result = {input, pos, result};
        return result;
    };

    function match(input, options) {
        try {
            var result = this.parse(input, options);
        } catch(err) {
            this.err = err;
            return null;
        }
        return result;
    }

    return {parse, match, grammar, actions, code};
}


// expose grit_parser ----------------------------------------------

grit_parser.operators = operex;

// module.exports = grit_parser;

if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = grit_parser;
} else if (typeof define === 'function' && define.amd) {
    define(function() { return grit_parser; });
} else {
    this.grit_parser = grit_parser;
}

}).call(function() {
return this || (typeof window !== 'undefined' ? window : global);
}()); // outer funtion name-space wrapper
    
    
</script>
<script>
    // window.gritbox -- global variable for gritbox HTML events to use.
    // expects grit-prser in: window.grit_parser, see below (line 33)....
    if (window.gritbox) throw new Error("Browser window.gritbox already in use? ...");
    window.gritbox = {};
    var gritbox = window.gritbox

    gritbox.RESET = (i) => {
	    var src = gritbox.textarea_src(i)
        var example = gritbox.example(i, 0)
	    src.value = example.value
	    gritbox.RUN(i);
    }
    gritbox.RUN = (i) => {
        var src = gritbox.textarea_src(i)
        var dst = gritbox.textarea_dst(i)
        var res = "";
        try {
            var verbs = {
                grit: window.grit_parser, // See above...
                operex: window.operex,
                write: (txt) => res += JSON.stringify(txt)+"\n",
                print: (txt) => res += JSON.stringify(txt, null, 2),
                nl: () => res += "\n"
            }
            var keys = Object.keys(verbs);
            var vals = keys.map((k)=> verbs[k])
            var fn = new Function(...keys, src.value)
            fn(...vals);
        } catch(err) {
            res = err
        }
        dst.value = res;
    }
    gritbox.SELECT = (i) => {
        var x = document.getElementById("gritbox-select-"+i).value;
        var example = gritbox.example(i, x-1)
        var src = gritbox.textarea_src(i)
        src.value = example.value
        gritbox.RUN(i);
    }
    gritbox.textarea_src = (i) => document.getElementById('gritbox-src-'+i);
    gritbox.textarea_dst = (i) => document.getElementById('gritbox-dst-'+i);
    gritbox.example = (i, n) => document.getElementById('gritbox-eg-'+i+'-'+n);
</script>
<style>
textarea {font-family: monospace; font-size:10pt; background:whitesmoke;}
</style>

</head>
<body>
<h1>Grit Grammar Parser Reference</h1>
<p>This reference guide is for the the NPM <code>grit-parser</code> package.
</p>
<p>Project repository: <a href='https://github.com/pcanz/grammar-parser'>https://github.com/pcanz/grammar-parser</a>
</p>
<h2>Usage</h2>
<p><strong>Node.js</strong>
</p>
<pre class="code"><code>    npm install grit-parser</code></pre>
<pre class="code"><code>    const grit = require("grit-parser");</code></pre>
<p>Or use a copy of the: <code>grit-parser.js</code> file from: <a href='https://github.com/pcanz/grammar-parser'>https://github.com/pcanz/grammar-parser</a> 
</p>
<pre class="code"><code>    const grit = require("./grit-parser.js");</code></pre>
<p><strong>Browser:</strong>
</p>
<p>Load a copy of the: <code>grit-parser.js</code> file from: <a href='https://github.com/pcanz/grammar-parser'>https://github.com/pcanz/grammar-parser</a>
</p>
<p>After it is loaded the bowser window global: <code>grit</code> is assigned the constructor function.
</p>
<p><strong>Using grit:</strong>
</p>
<p>The <code>grit</code> constructor function is best used as a JavaScript template literal tag:
</p>
<pre class="code"><code>    const my_grammar = grit` .... grammar rules .... `;</code></pre>
<p>But it can also be used as a regular function:
</p>
<pre class="code"><code>    const my_grammar = grit(" ... grammar rules ... ");</code></pre>
<p>Or better (to avoid the need to escape back-slash characters):
</p>
<pre class="code"><code>    const my_grammar = grit( String.raw` ... grammar rules ... ` );</code></pre>
<p><strong>Action functions</strong>
</p>
<p>Can be defined as:
</p>
<pre class="code"><code>    my_grammar.actions = {
        rule_action: ... JS function ... ,
        another: ...
    }</code></pre>
<p>Or as a second argument to the <code>grit</code> function:
</p>
<pre class="code"><code>    const my_grammar = grit(" ... grammar rules ... ", { ... action functions ... });</code></pre>
<p><strong>Parse Functions:</strong>
</p>
<pre class="code"><code>    const my_grammar = grit` .... grammar rules .... `;</code></pre>
<pre class="code"><code>    var parse_tree = my_grammar.parse(" ... input ...");</code></pre>
<p>The <code>parse</code> method will throw an exception if the parse fails for any reason.
</p>
<p>The <code>match</code> method is the same as the <code>parse</code> method, but it will return a null result if the grammar does not match the input.
</p>
<pre class="code"><code>    var parse_tree = my_grammar.match(" ... input ...");</code></pre>
<h2>PEG Rules</h2>
<p>A grammar rule names a PEG expression that contains string pattern matching components. 
</p>
<p>A PEG expression <code>e</code> may be either:
</p>
<ul data-tight='true'><li>a rule name reference -- to match the expression defined by that rule.</li><li>a string match component -- to directly match the input text.</li></ul>
<p>If <code>e1</code> and <code>e2</code> are PEG expressions, then so too is:
</p>
<ul data-tight='true'><li><code>e1 e2</code>    -- to match a sequence of e1 followed by e2</li><li><code>e1 / e2</code>  -- which matches e1, or e2 if and only if e1 fails</li><li><code>( e1 )</code>   -- to form a group</li></ul>
<p>The choice <code>e1 / e2</code> will only try <code>e2</code> if <code>e1</code> fails (first match wins), and there is no backtracking.
</p>
<ul data-tight='true'><li><code>e1 / e1 e2</code>  -- will therefore never match the second alternative.</li></ul>
<p>An empty match is not a failure, so: <code>e1* / e2</code> should never try to match e2. But in practice it is very easy to make this kind of mistake, and there seems to be no practical reason not to treat a match of nothing the same as a failure. So this is treated as a special case, and the parser will try to match <code>e2</code> if <code>e1</code> has not matched any input. 
</p>
<p>Any PEG expression e can be given a predicate prefix:
</p>
<ul data-tight='true'><li><code>&e</code> matches an empty string <code>''</code> if e matches, else it fails. No input is consumed.</li><li><code>!e</code> matches an empty string <code>''</code> if e does NOT match, else it fails. No input is consumed.</li></ul>
<p>Any PEG expression e can be given a repeat suffix:
</p>
<ul data-tight='true'><li><code>e*</code> results in an array with zero or more matches.</li><li><code>e+</code> results in an array with one or more matches.</li><li><code>e?</code> will either match <code>e</code> or an empty string <code>''</code>.</li></ul>
<p>The result of a repeat is always the longest match and no other.
</p>
<ul data-tight='true'><li><code>e* e</code>  -- will therefore always fail to match any input.</li></ul>
<p>The binding strength or precedence is (low to high):
</p>
<ul data-tight='true'><li><code>e1 / e2</code></li><li><code>e1 e2</code></li><li><code>&e !e</code></li><li><code>e* e+ e?</code></li></ul>
<p>So, for example:
</p>
<ul data-tight='true'><li><code>e1 e2* / e3 (e4 / e5+)*  =>  ((e1 e2*) / (e3 (e4 / e5+)*))</code></li></ul>
<h2>String Matching Components</h2>
<p>A string matching component in a grammar rule can be either:
</p>
<ul data-tight='false'><li><p>A literal quoted <q>string</q> or &rsquo;string&rsquo; to be matched.
- there are no escape codes.
- double-quote marks (but not single-quote marks) will skip surrounding white-space.</p></li><li><p>A regex to match a regular expression.
- a regex must start with <code>[</code> or <code>\</code> or <code>^</code>
- for example: <code>[abc]</code> or <code>\d</code> or <code>^(abc)</code>
- suffix repeats can be included in the regex, eg: <code>[abc]*</code> or <code>\d+</code>
- after the start the regex is not restricted (it can be any valid RegExp)
- for example: <code>[abc]*(\s*\d{3,4})*</code>
- the complete regex is evaluated as a single regular expression
- a regex can not contain any white-space, except in brackets, eg: <code>[ \t]*</code>
- the result is the full matched string, or the first capture group if there is one.</p></li></ul>
<p>Note that quoted literal <code>"x"</code> and the regex <code>[x]</code> will both match a literal character <code>x</code>, but  <code>"x"</code> will skip any surrounding white-space, so <code>"x"</code> is equivalent to the regex: <code>\s*(x)\s*</code>
</p>
<pre class="code"><code>'a+b+c' => regex: [a]\+b\+c
"a+b+c" => regex: \s*(a\+b\+c)\s*</code></pre>
<p>A <code>^</code> in a regex will only match at the beginning, but since each regex component is treated as a separate match it is not necessary to use a <code>^</code> at the start of a regex component (but it does no harm). Since any regex <em>may</em> begin with a <code>^</code> is can be used to introduce any regex component, for example, <code>^(x)+</code> is a regex to match one or more x characters, but <code>(x)+</code> is not a regex, it will match a list of one or more <code>x</code> rules.
</p>
<p>Ideally the regex components should be kept simple, such as a char-set eg: <code>[abc]</code>, or a repeated char-class eg: <code>\d+</code>. There is no loss of expressive power in keeping the regex matches simple since they are components in a larger PEG grammar. The PEG logic can include lookahead tests eg: <code>&x</code> for positive lookahead tests, or <code>!x</code> for negative lookahead tests, or a semantic action can be used.
</p>
<p>Simple regex components also eliminate troublesome issues with some regular expression implementations, see <a href='https://swtch.com/~rsc/regexp/regexp1.html'>Russ Cox</a> for details.
</p>

<h2>Semantic Actions</h2>
<p>Semantic actions are functions that are applied to the result of a rule match. The actions are defined as properties of an object, which can be assigned to the <code>actions</code> property of a parser:
</p>

  <div class="gritbox controls">
    
      <select id="gritbox-select-1" onchange="gritbox.SELECT(1)">
      
      <option value='1'>Example 1.1</option>
      <option value='2'>Example 1.2</option>
      </select>
    <button onClick='gritbox.RUN(1)'>RUN</button>
  </div>
  <textarea id='gritbox-src-1' style="width:49%" rows=19>const mdy = grit`
    date  = month '/' day '/' year
    day   = \d+
    month = \d{1,2}
    year  = \d{4}
`;

mdy.actions = {
    date: ([m, _, d, _1, y]) => new Date(y, m-1, d),
    day: (d) => Number(d),
    month: (m) => Number(m),
    year: (y) => Number(y)
}

var dt = mdy.parse("3/4/2019");

write(dt);</textarea>
  <textarea id='gritbox-dst-1' style="width:49%" rows=19></textarea>
  
      <textarea id='gritbox-eg-1-0' hidden>const mdy = grit`
    date  = month '/' day '/' year
    day   = \d+
    month = \d{1,2}
    year  = \d{4}
`;

mdy.actions = {
    date: ([m, _, d, _1, y]) => new Date(y, m-1, d),
    day: (d) => Number(d),
    month: (m) => Number(m),
    year: (y) => Number(y)
}

var dt = mdy.parse("3/4/2019");

write(dt);</textarea>
      <textarea id='gritbox-eg-1-1' hidden>const grammar = String.raw`
    date  = month '/' day '/' year
    day   = \d+
    month = \d{1,2}
    year  = \d{4}
`;

const actions = {
    date: ([m, _, d, _1, y]) => new Date(y, m-1, d),
    day: (d) => Number(d),
    month: (m) => Number(m),
    year: (y) => Number(y)
}

const mdy = grit(grammar, actions);

var dt = mdy.parse("3/4/2019");

write(dt);</textarea>
  <script>gritbox.RUN(1)</script><br>

<p>The function name corresponding to the rule name will be called with the result matched by that rule.
</p>
<p>The grit grammar parser constructor function may also be called with two arguments: the grammar rules, and the action functions, as in example 1.2.
</p>
<p>The name of a semantic action function may be appended to a rule with a <code>:</code> separator:
</p>

  <div class="gritbox controls">
    
      <select id="gritbox-select-2" onchange="gritbox.SELECT(2)">
      
      <option value='1'>Example 2.1</option>
      <option value='2'>Example 2.2</option>
      </select>
    <button onClick='gritbox.RUN(2)'>RUN</button>
  </div>
  <textarea id='gritbox-src-2' style="width:49%" rows=17>const mdy = grit`
    date  = month '/' day '/' year : date
    day   = \d+                    : num
    month = \d{1,2}                : num
    year  = \d{4}                  : num
`;

mdy.actions = {
    date: ([m, _, d, _1, y]) => new Date(y, m-1, d),
    num: (n) => Number(n)
}

var dt = mdy.parse("3/4/2019");

write(dt);</textarea>
  <textarea id='gritbox-dst-2' style="width:49%" rows=17></textarea>
  
      <textarea id='gritbox-eg-2-0' hidden>const mdy = grit`
    date  = month '/' day '/' year : date
    day   = \d+                    : num
    month = \d{1,2}                : num
    year  = \d{4}                  : num
`;

mdy.actions = {
    date: ([m, _, d, _1, y]) => new Date(y, m-1, d),
    num: (n) => Number(n)
}

var dt = mdy.parse("3/4/2019");

write(dt);</textarea>
      <textarea id='gritbox-eg-2-1' hidden>const grammar = String.raw`
    date  = month '/' day '/' year : date
    day   = \d+                    : num
    month = \d{1,2}                : num
    year  = \d{4}                  : num
`;

const actions = {
    date: ([m, _, d, _1, y]) => new Date(y, m-1, d),
    num: (d) => Number(d)
}

const mdy = grit(grammar, actions);

var dt = mdy.parse("3/4/2019");

write(dt);</textarea>
  <script>gritbox.RUN(2)</script><br>

<p>If the semantic action returns <code>null</code> then the rule will fail, otherwise the action may return any result as the rule result.
</p>
<p>If the rule has a semantic action function name that does not match a custom function then it may match a standard built-in function name.
</p>
<p>An application program can always process the default parse tree without using any semantic actions(in that case the parse tree result will be an array of arrays of string values). But it is often more convenient to break the parse tree processing into smaller functions applied to the result of an individual rule.
</p>
<p>For example, a calculator application could process the parse tree for arithmetic expressions, but it is simpler to break the calculator application into semantic action functions that incrementally process the results of individual grammar rules:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(3)' >Example 3</button>
    <button onClick='gritbox.RUN(3)'>RUN</button>
  </div>
  <textarea id='gritbox-src-3' style="width:49%" rows=19>const arith = grit`
  expr   = factor ([+-] factor)*
  factor = term ([*/] term)*
  term   = \d+ / "(" expr ")"
`;

arith.actions = {
  expr:   ([f, fs]) =>
            fs.reduce((y, [op, x]) =>
              op === '+'? y+x : y-x, f),   
  factor: ([t, ts]) =>
            ts.reduce((y, [op, x]) =>
              op === "*"? y*x : y/x, t),
  term:   (x) => Number(x) || x[1]
}

var e = arith.parse("1+2*(3+4)-5");

write(e);</textarea>
  <textarea id='gritbox-dst-3' style="width:49%" rows=19></textarea>
  
      <textarea id='gritbox-eg-3-0' hidden>const arith = grit`
  expr   = factor ([+-] factor)*
  factor = term ([*/] term)*
  term   = \d+ / "(" expr ")"
`;

arith.actions = {
  expr:   ([f, fs]) =>
            fs.reduce((y, [op, x]) =>
              op === '+'? y+x : y-x, f),   
  factor: ([t, ts]) =>
            ts.reduce((y, [op, x]) =>
              op === "*"? y*x : y/x, t),
  term:   (x) => Number(x) || x[1]
}

var e = arith.parse("1+2*(3+4)-5");

write(e);</textarea>
  <script>gritbox.RUN(3)</script><br>

<p>The action functions are called with two arguments:
</p>
<ul data-tight='true'><li>The rule result -- this is usually all that is required.</li><li><p>A parse object: <code>{ name, action, pos, input, posit}</code>
- name: the rule name
- <code>action</code>: the action appended to the rule
- <code>pos</code>: the current input position (after the rule match)
- <code>input</code>: the input string being parsed
- <code>posit(i)</code>: a function to set a new position.</p></li></ul>
<p>The second argument parse object is not often needed, but it gives the action function access to information that can be useful for debugging, or for experimental actions (extending the built-in functions), or even to take over for special case parsing if necessary.
</p>
<p>It is good practice to first develop a grammar parser without using any semantic action functions. This first priority is to ensure that the grammar rules recognize input strings correctly, regardless of the structure of the parse tree. After that the rules may be reorganized to simplify the parse tree, and finally semantic actions may be employed to process the parse tree as needed by the application.
</p>
<p>It is important to remember that a semantic action may be called before the rule later fails as a component in another rule. This is too late for any side effects the semantic action may have generated.
</p>
<h3>Built-in Functions</h3>
<p>The built-in functions:
</p>
<ul data-tight='true'><li><code>string</code> converts the result into a string.</li><li><code>number</code> converts the result into a number.</li><li><code>flatten</code> converts result to a flat list.</li></ul>
<p>Rules of this form: <code>x (op x)*</code> are an idiomatic way to match lists with separators, or arithmetic expressions, and many other formats. These rules generate an awkward parse tree structure which can be simplified by these standard functions:
</p>
<ul data-tight='true'><li>yfx returns a left associative tree.  e.g.  <code>1+2+3 => (1+2)+3</code></li><li>xfy returns a right associative tree.  e.g. <code>2^3^4 => 2^(3^4)</code></li><li>yfy returns a flat list including the operators. e.g. <code>1+2+3 => 1 + 2 + 3</code></li><li>xfx returns a flat list excluding the operators. e.g. <code>1+2+3 => 1 2 3</code></li></ul>
<p>The <code>yfx</code> and <code>xfy</code> actions generate parse tree nodes in this form:
</p>
<pre class="code" data-type='eg'>    [op, left_tree, right_tree]</pre>
<p>Here they are used to generate the desired parse tree for our arithmetic expression grammar:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(4)' >Example 4</button>
    <button onClick='gritbox.RUN(4)'>RUN</button>
  </div>
  <textarea id='gritbox-src-4' style="width:49%" rows=15>const expr = grit`
  expr   = factor ([+-] factor)*   : yfx
  factor = term ([*/] term)*       : yfx
  term   = prime ("^" prime)*      : xfy
  prime  = numb / group
  group  = "(" expr ")"            : _x
  numb   = \d+                     : number
`;

write( expr.parse(`1+2+3+4+5`) );

write( expr.parse(`2^3^4`) );

write( expr.parse(`1+2+3*(4+5)-6`) );
</textarea>
  <textarea id='gritbox-dst-4' style="width:49%" rows=15></textarea>
  
      <textarea id='gritbox-eg-4-0' hidden>const expr = grit`
  expr   = factor ([+-] factor)*   : yfx
  factor = term ([*/] term)*       : yfx
  term   = prime ("^" prime)*      : xfy
  prime  = numb / group
  group  = "(" expr ")"            : _x
  numb   = \d+                     : number
`;

write( expr.parse(`1+2+3+4+5`) );

write( expr.parse(`2^3^4`) );

write( expr.parse(`1+2+3*(4+5)-6`) );
</textarea>
  <script>gritbox.RUN(4)</script><br>

<p>The tree structures:
</p>
<pre class="code" data-type='box'>              +                 ^          
             / \               / \         
  yfx:      +   4      xfy:   1   ^        yfy:  1 + 2 + 3 + 4    xfx:  1 2 3 4 
           / \                   / \
          +   3                 2   ^    
         / \                       / \
        1   2                     3   4     </pre>
<p>The semantic actions can be thought of as a sort of type specification for the rule result, which can be appended to the end of the rule.
</p>
<h2>Debug Trace</h2>
<p>The <code>parse</code> function has a second argument for options, which can generate a trace log to help debug a grammar. 
</p>
<p>Here is an example of using a trace:
</p>
<pre class="code" data-type='eg'>    const arith = grit`
        expr   = factor ([+-] factor)*
        factor = term ([*/] term)*
        term   = \d+ / "(" expr ")"
    `;

    var e = expr.parse("1+2*(3+4)-5", {trace: true} );

    0..1 term /\d+/y =>1
    1 factor /[*\/]/y !
    1..2 expr /[+-]/y =>+
    2..3 term /\d+/y =>2
    3..4 factor /[*\/]/y =>*
    4 term /\d+/y !
    4..5 term /\s*(\()/y =>(
    5..6 term /\d+/y =>3
    6 factor /[*\/]/y !
    6..7 expr /[+-]/y =>+
    7..8 term /\d+/y =>4
    8 factor /[*\/]/y !
    8 expr /[+-]/y !
    8..9 term /\s*(\))/y =>)
    9 factor /[*\/]/y !
    9..10 expr /[+-]/y =>-
    10..11 term /\d+/y =>5
    11 factor /[*\/]/y !
    11 expr /[+-]/y !
</pre>
<p>The numbers on the left are the input position of the match components with the name of the rule the component is in. Only the input match operations are logged in the trace, they usually give the most useful information, and a full trace of all rules can be very verbose.  
</p>
<h2>Grammar Grammar</h2>
<p>The grammar rules can define themselves. Here is a minimal grammar that is sufficient to define itself and parse itself:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(5)' >Example 5</button>
    <button onClick='gritbox.RUN(5)'>RUN</button>
  </div>
  <textarea id='gritbox-src-5' style="width:49%" rows=19>const g1 = String.raw`
    grammar = (ws rule ws)+
    rule    = name ws [=] expr

    expr    = seq (ws [/] seq)*
    seq     = ([ ]* term [*+?]?)*
    term    = name / match / group

    name    = [\w]+
    match   = [[] [^\x5D]+ [\x5D] [*+?]?
    group   = [(] expr [)]

    ws      = [\s]*
`;

var p = grit(g1).parse(g1);

print(p);
</textarea>
  <textarea id='gritbox-dst-5' style="width:49%" rows=19></textarea>
  
      <textarea id='gritbox-eg-5-0' hidden>const g1 = String.raw`
    grammar = (ws rule ws)+
    rule    = name ws [=] expr

    expr    = seq (ws [/] seq)*
    seq     = ([ ]* term [*+?]?)*
    term    = name / match / group

    name    = [\w]+
    match   = [[] [^\x5D]+ [\x5D] [*+?]?
    group   = [(] expr [)]

    ws      = [\s]*
`;

var p = grit(g1).parse(g1);

print(p);
</textarea>
  <script>gritbox.RUN(5)</script><br>

<p>This grammar only accepts simple regex char-set string match components. 
</p>
<p>Here is the full grit grammar grammar:
</p>
<pre class="code" data-type='eg'>    grammar = rule+
    rule    = name "=" expr ws act?

    expr    = seq ("/" seq)*
    seq     = (ws [&!]? term [*+?]?)*
    term    = ref / quote / regex / group

    name    = ws \w+
    ref     = name !\s*=
    group   = "(" expr ")"

    quote   = '"' [^"]* '"' / "'" [^']* "'"
    regex   = &[[\\^] (chs / par / misc)+
    chs     = [\[] ([^\]\\]* ([\\][^])?)+ [\]]
    par     = [(] ([^()]* par?)* [)]
    misc    = [^[()\s]+

    act     = ":" lines
    lines   = line (\s* !\S+\s*= line)*
    line    = [^\n\r]* 
    ws      = \s*  </pre>


</body>
</html>
