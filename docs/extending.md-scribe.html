<!DOCTYPE HTML>
<html>
<head>
<meta lang=en charset="UTF-8">
<style>
body {
    font-family: 'Helvetica Neue', Helvetica, Arial, serif;
    font-size: 1em; line-height: 1.5; color: #505050;
}
.code { background: whitesmoke; margin:0pt 10pt;}
blockquote {border-left: solid thick gainsboro; padding-left:5pt;}
h1,h2,h3,h4 {border-bottom: thin solid gainsboro; }
.key-val { margin:0px; }
.key-val-blk { margin:0px; margin-left:20pt; }
[data-tight='false'] > li {margin-bottom:12pt;}
q { quotes: "“" "”" "‘" "’"; }

</style>
<script>
// grit-parser loads itself into: window.grit_parser
// Grammar Parser -- an evolution of Grit.

// See docs at: https://github.com/pcanz/grammar-parser

/*	The MIT License (MIT)
 *
 *	Copyright (c) 2015,2016,2017,2018,2019 Peter Cashin
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files(the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 *	furnished to do so, subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included
 *	in all copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 *	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

;(function() { // module name-space wrapper -- see the end of this file...

/* -- grammar-rule grammar ---------------------------------------

    grammar = rule+
    rule    = name "=" expr ws act?

    expr    = seq ("/" seq)*
    seq     = (ws [&!]? term [*+?]?)*
    term    = ref / quote / regex / group

    name    = ws \w+
    ref     = name !\s*=
    group   = "(" expr ")"

    quote   = '"' [^"]* '"' / "'" [^']* "'"
    regex   = &[[\\^] (chs / par / misc)+
    chs     = [\[] ([^\]\\]* ([\\][^])?)+ [\]]
    par     = [(] ([^()]* par?)* [)]
    misc    = [^[()\s]+

    act     = ":" lines
    lines   = line (\s* !\S+\s*= line)*
    line    = [^\n\r]* 
    ws      = \s*  
*/

// -- parser code for grit_rules --------------------------------------

// The parser is a byte-code style interpreter, but encodes
// instructions an array data structure with string values.

/* parser instruction codes:

    ["^", "regex"]      match regexp
    ["=", rule]         call rule by name.
    [",", a, b, c, ...] sequence of instruction codes, all to succeed.
    ["/", a, b, c, ...] alternatives, first to succeed.
    ["+", x]            matches one or more x, or fails.
    ["*", x]            matches any number of x, none matches "".
    ["?", x]            optional match: x / ""
    ["&", x]            lookahead: "" if x matches, else fails.
    ["!", x]            negation: fails if x matches, else "".
    
    The parser compiles rule names to rule indexes on the fly, and also
    compiles regexp's on the fly (to keep the code simple, and portable).

    The parser code can be exported as JSON.
*/

const grit_code = [
    {   name: "__grit__grammar", // grammar = rule+
        code: ["+",["=","rule"]] },

    {   name: "rule", // rule = name "=" expr ws act?
        code: [",",["=","name"],["^","\\s*="],["=","expr"],
                        ["=", "ws"],["?",["=","act"]]] },

    {   name: "expr", // expr = seq ("/" seq)*
        code: [",",["=","seq"],["*",[",",["^","\\s*/"],["=","seq"]]]] },

    {   // seq = (ws [&!]? term [*+?]?)*
        name: "seq",
        code: ["*",[",",["=","ws"],["^","[&!]?"],["=","term"],["^","[*+?]?"]]] },

    {   name: "term", // term = ref / quote/ regex / group
        code: ["/",["=","ref"],["=","quote"],["=","regex"],["=","group"]] },

    {   name: "name", // name = ws \w+
        code: [",",["^","[\\s]*"],["^","[\\w]+"]] },

    {   name: "ref", // ref = name !\s*=
        code: [",",["=","name"],["!",["^","[\\s]*="]]] },

    {   name: "quote", // quote = '"' [^"]* '"' / "'" [^']* "'"
        code: ["^","\\s*((?:'[^']*'|\"[^\"]*\")[\\w]*)"] },

    {   name: "regex", // regex = &[[\\^] (chs / par / misc)+
        code: [",",["&",["^","[[\\\\^]"]],["+",["/",["=","chs"],["=","par"],["=","misc"]]]] },

    {   name: "chs", // [\[] ([^\]\\]* ([\\][^])?)+ [\]]
        code: ["^","[[](?:[^\\]\\\\]*(?:[\\\\][^])?)+[\\]]"] },

    {   name: "par", // par = [(] ([^()]* par?)* [)]
        code: [",",["^","[(]"],["*",[",",["^","[^()]*"],["?",["=","par"]]]],["^","[)]"]] },

    {   name: "misc", // [^[()\s]+
        code: ["^","[^[()\\s]+"] },

    {   name: "group", // group = "(" expr ")"
        code: [",",["^","\\s*\\("],["=","expr"],["^","\\s*\\)"]] },

    {   name: "act", // act = ":" lines
        code: [",",["^","\\s*:"],["^","[^\\n\\r]*"], // line = [^\n\r]*
                ["*",[",",["^","\\s*"],["!",["^","\\S+\\s*="]],
                            ["^","[^\\n\\r]*"]]]] },

    {   name: "ws", // ws = \s* 
        code: ["^","\\s*"] }
];

resolve_code(grit_code); // maps names to indexes & compiles regexes

// -- compile peg rules into parser instruction codes --------------------

const grit_actions = { // semantic actions for parse tree nodes...

    // grammar = rule+
    "grammar": (rs) => rs,

    // rule = name "=" expr ws act?
    "rule": ([name, _, code, ws, action]) => {
        return {name, code, action};
    },

    // expr = seq ("/" seq)*
    "expr": ([seq, alts]) => {
        if (alts.length === 0) {
            return seq;
        } else {
            var seqs = alts.map(([_, seq]) => seq)
            return ["/", seq, ...seqs];
        }
    },

    // seq = (ws [&!]? term [*+?]?)*
    "seq": (xs) => {
        var ts = xs.map(([ws, pred, term, rep]) => {
            if (rep) { term = [rep, term]; }
            if (pred) { term = [pred, term];}
            return term;
        })
        if (ts.length === 1) return ts[0];
        return [",", ...ts];
    },

    // term = ref / match / group
    "term": (x) => x,

    // name = ws \w+
    "name": ([_, name]) => name,

    // ref = name !\s*=
    "ref":  ([name, _]) => ["=", name, null],

    // group = "(" expr ")"
    "group": ([_, expr]) => expr,

    // quote = '"' [^"]* '"' / "'" [^']* "'"
    "quote": (str) => { // quote => regex: \s*("...")\s*
        if (str.length === 2) { // empty quotes..
            return (str[0] === "'")? ["^","\uFFFF?"] : ["^","\\s*(\uFFFF?)"];
        }
        qt = str.slice(1,-1);
        if (str[0] === "'") return ["^",esc_regex(qt)];
        return ["^","\\s*("+esc_regex(qt)+")\\s*"];
    },

    // // regex   = &[[\\^] (chs / par / misc)*
    // "regex": ([_, rs]) => rs[0]==='^'? 
    //             ["^", rs.slice(1).join('')] : ["^", rs.join('')],

    // regex   = &[[\\^] (chs / par / misc)*
    "regex": ([_, rs]) => rs[0] && rs[0][0]==='^'? 
                ["^", rs[0].slice(1)+rs.slice(1).join('')]
                : ["^", rs.join('')],

    // par = [(] ([^()]* par?)* [)]
    "par": ([lp, ps, rp]) => { // par? => p, will be already done..
        var xps = ps.map(([x, p]) => p? x+p : x);
        return lp + xps.join('') + rp; 
    },

    // act = ":" lines
    "act": ([_, line, lines]) => {
        return string([line, lines]);
    },

    // ws = \s*
    "ws": (s) => s

} // grit_actions

function esc_regex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function rules_map(code) {
    return code.reduce((rm, rule, idx) => {
        rm[rule.name] = idx; return rm; }, {});
}

function resolve_code(code) {
    var name_idx = rules_map(code);

    function resolve (op) {
        if (!Array.isArray(op)) return op;
        if (op[0] === "^") {
            op[2] = op[2] || new RegExp(op[1],"yus"); // sticky unicode dots flags
            return op;
        }
        if (op[0] === "=") {
            op[2] = name_idx[op[1]];
            if (!op[2] && op[2]!==0) {
                throw new Error("*** missing rule '"+op[1]+"' ... ")
            }
            return op;
        }
        return op.map((x) => resolve(x));
    }
    var coded = code.map((rule) => {
        return resolve(rule.code);
    });

    return code;
}
    
// -- parser -- string-code interpreter ------------------------------------

const ANON = "__anon__"; // default name for first rule

function parser (code, input, actions={}, options={}) {
    var pos = 0;
    var inRule = "start"; // current rule trace 
    var ruleStack = [];
    var maxPos = 0; // high water mark
    var maxRule= ""; // inRule at maxPos
    var runOps = 0;
    var maxOps = 10000; // run away recursion check

    if (!code) {
        return report("missing grammar rule code...");
    }

    var start_name = code[0].name;
    var start = ["=", start_name, 0];

    if (typeof input !== "string") {
        try { // tag`grammar..` => tag([grammar...], ${}...)
            input = String.raw(input);
            if (!input.match(/^\s*\S+\s*=/)) {
                input = ANON+" = "+input; // simple regex grammar
            }
        } catch(err) {
            input = '';
            return report("input is not a string...");
        }
    }

    if (typeof actions === 'function') {
        actions = { "?": actions } // catch all
    }

    if (options.trace) console.log("trace", start_name)

    var result = run(start); // run the parser engine...

    if (result === null) {
        return report("failed");
    }
    if (pos < input.length && !input.slice(pos).match(/^\s+$/)) {
        if (options.replay) replay();
        return report("fell short");
    }
    return [result, pos];

    // -- code engine -------------------------------------------

    function run(op) {

        if (runOps += 1 > maxOps) {
            return report("run away recursion...");
        }

        switch (op[0]) {

        case '^': // ["^", src, regex]
            var regex = op[2]; 
            regex.lastIndex = pos; // using regex.y sticky flag
            var mx = regex.exec(input);
            var trace = options.trace;
            if (trace) {
                if (typeof trace !== "string" || trace === inRule) {
                    var span = pos;
                    span += mx? ".."+(pos+mx[0].length) : ""
                    var match = mx? "=>"+mx[0] : "!";
                    console.log(span,inRule,regex,match);
                }
            }
            if (!mx) return null;
            pos += mx[0].length;
            if (pos > maxPos) { 
                maxPos = pos; 
                maxRule = inRule;
            }
            // return mx[1]||mx[0]; // used to skip white-space prefix
            if (mx.length === 1) return mx[0];
            if (mx.length === 2) return mx[1];
            return mx.slice(1);

        case '=': // ["=", name, idx]
            var idx = op[2];
            var rule = code[idx];
            if (!rule) { // bad grammar ...
                return report("missing rule "+idx+": '"+op[1]+"' ...");
            }
            ruleStack.push(inRule)
            inRule = op[1];
            var start = pos;
            var result = run(rule.code);
            inRule = ruleStack.pop();
            if (result === null) {
                pos = start;
                return null;
            }
            var {name, action} = rule;
            var val = run_action(result, {name, action, pos, input, posit, env:options});
            if (val !== null) return val;
            pos = start; // fail
            return null;

        case ',': // [",", ..., seq, ... ]
            var start = pos;
            var res = [];
            var i = 1;
                while (i < op.length) {
                var temp = run(op[i]);
                if (temp === null) {
                    pos = start;
                    return null;
                }
                res.push(temp);
                i += 1;
            }
            return res;

        case '/': // ["/", ..., alt, ... ]
            var start = pos;
            var res = null; // fail if no alt
            var j = 1;
            while (j < op.length) {
                res = run(op[j]);
                if (res !== null && pos > start) {
                    return res;
                }
                pos = start;
                j += 1;
            }
            return res;

        case '*': // ["*", op]
        var start = pos;
        var temp = run(op[1]);
        if (temp === null) return [];
        var res = [temp];
        while (true) {
            start = pos;
            temp = run(op[1]);
            if (temp === null || pos === start) break;
            res.push(temp);
        }
        return res;

        case '+': // ["+", op]
            var start = pos;
            var temp = run(op[1]);
            if (temp === null) return null;
            var res = [temp];
            while (true) {
                start = pos;
                temp = run(op[1]);
                if (temp === null || pos === start) break;
                res.push(temp);
            }
            return res;

        case '?': // ["?", op]
            var res = run(op[1])
            if (res === null) return "";
            return res;

        case '!': // ["!", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res === null) return "";
            return null;

        case '&': // ["&", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res !== null) return "";
            return null;

        default: // should never happen...
            throw new Error("*** Undefined parse code op: "+JSON.stringify(op));
        }
    } // run

    function report(msg) {
        var [line, col] = line_of(pos);
        var lx = " "+line+"."+col;
        // var at = pos + (maxPos>pos? ".."+maxPos : "") + " of " + input.length;
        //var pre = pos<16? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var pre = line<2? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var show = pre + input.slice(pos,pos+40);
        show = show.replace(/[\x00-\x1f]/g,(c) => {
            if (c === "\n" || c === "r") return "\u00AC";
            if (c === "\t") return "\u2023"
            return "\u00A4";
        })
        // show = show.replace(/[\x00-\x1f]/g,"¬")
        if (input.length > pos+40) show += "..."
        var cursor = "";
        for (var i=0; i < pre.length; i+=1) cursor += " ";
        cursor += "^";
        if (maxPos > pos) {
            var max = maxPos-pos>40? 42 : maxPos;
            for (var i=pos+1; i < max; i+=1) cursor += " ";
            cursor += "^";
        }
        var report;
        if (start_name == "__grit__grammar") {
            report = "*** grammar rule syntax err, line:"+lx+
                    "\n"+show+"\n"+cursor;
        } else {
            report = "*** grammar '"+start_name+"' parse "+msg+
                    "\n'"+maxRule+"' at line:"+lx+
                    "\n"+show+"\n"+cursor;
        };
        if (!options || (!options.silent && !options.console)) {
            throw new Error(report);
        } else if (options.console && !options.silent) {
            console.log(report);
        } else { // silent reporting...
            options.report = report;
        }
        return [null, pos];
    }

    function line_of(pos) {
        let ln = 1, col = 0;
        for (let i = 0; i <= pos; i+=1) {
            const char = input[i];
            if (char === "\n") {
                ln += 1;
                col = 0;
            } else if (char === "\r") { // \r\n?
                if (i < pos && input[i+1] === "\n") i += 1;
                ln += 1;
                col = 0;
            } else col += 1;
        };
        return [ln, col];
    }

    function replay() {
        try {
            parser(code, input, actions, {trace:true});
        } catch(err) {
            // console.log(err);
        }
    }

    function posit(n) {
        // console.log("posit", pos, n);
        pos = n;
    }

    var cache = {};

    function run_action(result, parse) {
        var fn = null;
        var {name, action} = parse; // {name, action, pos, input, posit, env}
        if (action) {
            var ax = action.match(/^\s*(\S+)/);
            act = ax? ax[1] : "";
            fn = actions[act] || std_actions[act];
            if (!fn) { // synthetic action: _x_ etc..
                if (act.match(/^[_x]+$/) && Array.isArray(result)) {
                    var res = [];
                    result.forEach((x, i) => {
                        var k = act[i];
                        if (k === "x") res.push(x);
                    });
                    if (res.length === 1) return res[0];
                    return res;
                } else if (act) { // undefined action name...
                    report(`Missing action: '${act}' for rule: '${name}' ...`);
                }            
            }
        } // action
        const action_function = fn || actions[name] || actions["?"];
        if (action_function) {
            try {
                return action_function(result, parse);
                // return fn(result, {...parse, _:parse, $:parse.cache });
            } catch(err) {
                report("Bad action for '"+name+"':\n"+err);
            }
        }
        return result // [name, result] // default result..
    }


} // parser

// -- built-in semantic actions ---------------------------------------------

const std_actions = {

    yfx: ([x, ys]) => // x (op y)* => [op,x,y]
        ys.reduce((y, [op, z]) => [op, y, z], x),

    xfy: function xfy([x, ys]) {
        if (!ys || ys.length < 1) return x;
        let [[op,y], ...zs] = ys;
        return [op, x, xfy([y, zs])];
    },

    yfy: ([a, bs]) => { // a (op b)* => [a,op,b,op,c,...]
        return bs.reduce((y, b) => y.concat(b), [a])
    },

    xfx: ([a, bs]) => { // a (_ b)* => [a,b,c,...]
        return bs.reduce((y, [_, b]) => y.concat(b), [a]);
    },

    _x: ([_,x]) => x,

    flatten: (xs) => flatten(xs),

    string: (xs) => string(xs),

    number: (xs) => Number(string(xs)),

    x: (result) => result,
    n: (result) => Number(result),
    _: (result) => ""

}

function flatten(xs) {
    return Array.isArray(xs)?
        xs.reduce((y,x) => y.concat(flatten(x)),[]) : xs;
}

function string(xs) {
    return Array.isArray(xs)? flatten(xs).join('') : xs;
}

// == Operator expression function ==============================

function operex(...op_spec) { // => opex parser function

    const opdef = encodeOps(op_spec);

    /* == operator defintions ==
        const opex = operex(
            ["fy", "+", "-"],   // prefix, tightly bound
            ["xfy", "^"],
            ["yfx", "*", "/"],
            ["yfx", "+", "-"],
            ["xfy", "="]         // loosely bound
        );

        The operators are encoded into an op key map: opdef,
        indexed n = 1,3,5,7,..., binding strength, tighest = 1
        binding strengths: [prefix, left, right, suffix]:
            fx =>  [n,0,0,0];
            fy =>  [n+1,0,0,0]; 
            xfx => [0,n,n,0];   // [pfx,left,right,sfx]
            yfx => [0,n+1,n,0];
            xfy => [0,n,n+1,0];
            xf =>  [0,0,0,n];
            yf =>  [0,0,0,n+1];

        opdef = {
            "+": [1,8,7,0],  // fy , yfx
            "-": [1,8,7,0],
            "^": [0,3,4,0],  // xfy left < right
            "*": [0,6,5,0],  // yfx left > right
            ...
        }

        node = [op, left, right]
            left == null => prefix
            right == null => suffix
    */
    const nodePower = (node) => {
        if (!Array.isArray(node)) return 0;   // e.g operad
        let [op, left, right] = node;
        if (!opdef[op]) return 0;             // e.g "()"
        if (!left) return prefixPower(op);
        if (!right) return suffixPower(op);
        return infixRight(op);
    }  
    const prefixPower = (op) => opdef[op][0];
    const infixLeft = (op) => opdef[op][1];
    const infixRight = (op) => opdef[op][2];
    const suffixPower = (op) => opdef[op][3];

    const isPrefix = (op) => opdef[op] && opdef[op][0]>0;
    const isInfix = (op) => opdef[op] && opdef[op][1]>0;
    const isSuffix = (op) => opdef[op] && opdef[op][3]>0;

    const is_fy = (op) => opdef[op][0]%2==0;
    const is_yf = (op) => opdef[op][3]%2==0;

    const isOp = (op) => opdef[op];
    const notOp = (op) => !opdef[op];


    // -- encode operators ---------------------------------------------------

    function encodeOps(ops) {
        const opdef = {};
        ops.map((op, i) => { // eg  op = ["yfx", "+", "-"]
            const n = 2*i+1; // 2,4,6,8,...
            op.slice(1).map((sym) => {
                const defn = opdef[sym] || [0,0,0,0];
                const type = op[0];
                if (type === "fx") defn[0] = n;
                else if (type === "fy") defn[0] = n+1;
                else if (type === "xfx") {defn[1] = n; defn[2] = n; }
                else if (type === "xfy") {defn[1] = n; defn[2] = n+1; }
                else if (type === "yfx") {defn[1] = n+1; defn[2] = n; }
                else if (type === "xf") defn[3] = n;
                else if (type === "yf") defn[3] = n+1;
                opdef[sym] = defn; 
            });
        });
        return opdef;
    }

    const op_type = (op) => { // decode...
        const defn = opdef[op];
        if (!defn) return "undefined";
        var sign = "";
        if (defn[0]>0) sign += defn[0]%2==0? "fx":"fy";
        if (defn[1]>0 && defn[1]==defn[2]) sign += " xfx";
        if (defn[1]<defn[2]) sign += " xfy";
        if (defn[1]>defn[2]) sign += " yfx";
        if (defn[3]>0) sign += defn[0]%2==0? " xf":" yf";
        return sign;
    }


    // -- parser ---------------------------------------------------

    function opex(xs) { // xs = tokens...
        //     console.log("opex",xs);
        var tree=[], pos=0;

        if (xs.length === 0) return "";
        if (xs.length === 1) return xs[0];

        // p=prefix, i=infix, s=suffix, x,y=operands
        // valid:  p* x (s* (i p* y)?)? 
        tree = prefixed(); // tree = p* x

        while (pos < xs.length) { // valid: s* (i p* y)?
            var op = xs[pos++];
            if (isSuffix(op) && (!isInfix(op) || !xs[pos] || isOp(xs[pos]))) {
                tree = insertSuffix(tree, op);
                continue;
            }
            if (!isInfix(op)) { // (i p* y)?
                let msg = `expecting infix operator, found: '${op}' ${op_type(op)}`;
                fault(tree, [op], msg);
            }
            var y = prefixed();
            tree = insertInfix(tree, op, y);
        }
        return tree

        function prefixed() { // p* x => 
            var k = pos;
            while (k<xs.length && isPrefix(xs[k])) k+=1;
            if (isOp(xs[k])) { // p* !x
                let msg = `expecting operand, found: '${xs[k]}' ${op_type(op)}`;
                fault(tree, xs.slice(pos,k+1), msg);
            }
            if (k === pos) return xs[pos++]; // x
            var pfx = xs[pos++];
            var result = [pfx, null, xs[pos++]];
            return prefixChain(result, k);
        }
        function prefixChain(node, k) { // p+ x => p(p(..p(x))..)
            if (pos > k) return node;
            var [pfx1, _, pfx2] = node;
            if (prefixPower(pfx1) > prefixPower(pfx2)) {
                let msg = `prefix conflict: '${pfx1}' ${op_type(pfx1)}, '${pfx2}' ${op_type(pfx2)}`;
                fault(tree, xs.slice(pos-1,pos+1), msg);
            }
            node[2] = prefixChain([pfx2, null, xs[pos++]], k);
            return node;
        }

    } // opex

    const insertInfix = (tree, op, z, m = infixLeft(op)) => {
        let n = nodePower(tree);
        if (n < m || !tree[2]) return [op, tree, z];
        if (isLeaf(tree[2])) {
            tree[2] = [op, tree[2], z];
            return tree;
        }
        if (n > m) {
            tree[2] = insertInfix(tree[2], op, z, m);
            return tree;
        }
        fault(tree, [op, z], `invalid '${op}' ${op_type(op)}`);
    }

    const insertSuffix = (tree, sfx, m = suffixPower(sfx)) => {
        let n = nodePower(tree);
        if (n < m || !tree[2]) return [sfx, tree, null];
        if (isLeaf(tree[2])) {
            tree[2] = [sfx, tree[2], null];
            return tree;
        }
        if (n > m) {
            tree[2] = insertSuffix(tree[2], sfx, m);
            return tree;
        }
        if (n === m && is_yf(sfx)) { // must be yf
            tree[2] = [sfx, tree[2], null];
            return tree;
        }
        fault(tree, [sfx, null], `invalid '${sfx}' ${op_type(sfx)}`);
    }

    const isLeaf = (x) => !x || !Array.isArray(x) || notOp(x[0]);

    const fault = (tree, rest, msg) => {
        const ast = JSON.stringify(tree);
        throw new Error(`Bad op expr: ${msg}\n${ast} ${rest.join(" ")}`);
    }

    return opex;
} // operex
    
// -- grit_parser --------------------------------------------------------

function grit_parser (grammar, actions) {

    let [code, _] = parser(grit_code, grammar, grit_actions)

    if (!code) return null;
    
    resolve_code(code);

    function parse(input, options) {
        const [result, pos] = parser(code, input, this.actions, options);
        this.result = {input, pos, result};
        return result;
    };

    function match(input, options) {
        try {
            var result = this.parse(input, options);
        } catch(err) {
            this.err = err;
            return null;
        }
        return result;
    }

    return {parse, match, grammar, actions, code};
}


// expose grit_parser ----------------------------------------------

grit_parser.operators = operex;

// module.exports = grit_parser;

if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = grit_parser;
} else if (typeof define === 'function' && define.amd) {
    define(function() { return grit_parser; });
} else {
    this.grit_parser = grit_parser;
}

}).call(function() {
return this || (typeof window !== 'undefined' ? window : global);
}()); // outer funtion name-space wrapper
    
    
</script>
<script>
    // window.gritbox -- global variable for gritbox HTML events to use.
    // expects grit-prser in: window.grit_parser, see below (line 33)....
    if (window.gritbox) throw new Error("Browser window.gritbox already in use? ...");
    window.gritbox = {};
    var gritbox = window.gritbox

    gritbox.RESET = (i) => {
	    var src = gritbox.textarea_src(i)
        var example = gritbox.example(i, 0)
	    src.value = example.value
	    gritbox.RUN(i);
    }
    gritbox.RUN = (i) => {
        var src = gritbox.textarea_src(i)
        var dst = gritbox.textarea_dst(i)
        var res = "";
        try {
            var verbs = {
                grit: window.grit_parser, // See above...
                operex: window.operex,
                write: (txt) => res += JSON.stringify(txt)+"\n",
                print: (txt) => res += JSON.stringify(txt, null, 2),
                nl: () => res += "\n"
            }
            var keys = Object.keys(verbs);
            var vals = keys.map((k)=> verbs[k])
            var fn = new Function(...keys, src.value)
            fn(...vals);
        } catch(err) {
            res = err
        }
        dst.value = res;
    }
    gritbox.SELECT = (i) => {
        var x = document.getElementById("gritbox-select-"+i).value;
        var example = gritbox.example(i, x-1)
        var src = gritbox.textarea_src(i)
        src.value = example.value
        gritbox.RUN(i);
    }
    gritbox.textarea_src = (i) => document.getElementById('gritbox-src-'+i);
    gritbox.textarea_dst = (i) => document.getElementById('gritbox-dst-'+i);
    gritbox.example = (i, n) => document.getElementById('gritbox-eg-'+i+'-'+n);
</script>
<style>
textarea {font-family: monospace; font-size:10pt; background:whitesmoke;}
</style>

</head>
<body>
<h1>Extending The Grammar</h1>
<p>Most computer languages and data formats can be parsed with Grit grammar rules, but there are a few exceptions that may require the grammar to be extended.  A grammar rule extension can be implemented with an action function.
</p>
<p>Action functions allow the full power of the host programming language to be used to extend the grammar rules. This is an escape-hatch that needs to used carefully, but sometimes it is the only way to get the job done.
</p>
<h2>Matching The Same Again</h2>
<p>Consider for example a quoted string format that allows <em>any</em> number of quote marks at the start matched by the <em>same</em> number at the end. This format has the advantage that it can quote text that contains any number of quote marks. If there is a sequence of N quote marks in the content, then the outer quotes can use N+1 quote marks.
</p>
<p>If only a small number of different quote marks are needed then we could write a grammar with a separate rule to match a single quote mark, two quote marks, three, four, and so on. This obviously becomes impractical for more than a small number of rules.
</p>
<p>If the regular expression package supports <code>\1</code> to mean match the same text as the first capture group, then this regular expression will do the trick:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(1)' >Example 1</button>
    <button onClick='gritbox.RUN(1)'>RUN</button>
  </div>
  <textarea id='gritbox-src-1' style="width:49%" rows=10>const raw = grit`
    raw = ^('+)(.*?)\1
`;
raw.actions = {
    raw: ([_,x]) => x
}

const test = `'''xx ''y'' zz'''`;

write(raw.parse(test));</textarea>
  <textarea id='gritbox-dst-1' style="width:49%" rows=10></textarea>
  
      <textarea id='gritbox-eg-1-0' hidden>const raw = grit`
    raw = ^('+)(.*?)\1
`;
raw.actions = {
    raw: ([_,x]) => x
}

const test = `'''xx ''y'' zz'''`;

write(raw.parse(test));</textarea>
  <script>gritbox.RUN(1)</script><br>

<p>Not all regular expression packages have been extended to include this feature. Technically it is is not a regular expression anymore, and there are good reasons why it may be best to avoid this regex feature <a href='https://swtch.com/~rsc/regexp/regexp1.html'>Cox</a>.
</p>

<p>Grammar rules with action functions can be used to do the same thing:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(2)' >Example 2</button>
    <button onClick='gritbox.RUN(2)'>RUN</button>
  </div>
  <textarea id='gritbox-src-2' style="width:49%" rows=16>const raw = grit`
    raw = q1 chs* q2
    chs = !q2 [']*[^']*
    q1  = [']+  : save
    q2  = [']+  : match
`;
raw.actions = {
    raw: ([_,x]) => x.join(''),
    chs: ([_,x]) => x,
    save: (x) => raw.quotes = x,
    match: (x) => x == raw.quotes || null
}

const test = `'''xx ''y'' zz'''`;

write(raw.parse(test));</textarea>
  <textarea id='gritbox-dst-2' style="width:49%" rows=16></textarea>
  
      <textarea id='gritbox-eg-2-0' hidden>const raw = grit`
    raw = q1 chs* q2
    chs = !q2 [']*[^']*
    q1  = [']+  : save
    q2  = [']+  : match
`;
raw.actions = {
    raw: ([_,x]) => x.join(''),
    chs: ([_,x]) => x,
    save: (x) => raw.quotes = x,
    match: (x) => x == raw.quotes || null
}

const test = `'''xx ''y'' zz'''`;

write(raw.parse(test));</textarea>
  <script>gritbox.RUN(2)</script><br>

<p>The <code>q1</code> and <code>q2</code> are the outer quote marks, which must be the same. The <code>save</code> function records the <code>q1</code> open quote marks, and the <code>match</code> function checks that <code>q2</code> is the same as <code>q1</code>. A <code>null</code> result from <code>match</code> action function will cause the <code>q2</code> rule to fail.
</p>
<p>The text between the outer quote marks can contain anything except the <code>q2</code> end quote, so any characters that do not contain a quote mark, or any sequence of quote marks that do not match <code>q2</code> can be accepted.
</p>
<p>It is a good convention to give the <code>save</code> and <code>mark</code> functions meaningful names that are explicit in the grammar rules. This will help readers to spot the fact that these grammar rules depend on their action functions.
</p>
<h2>XML Tag Matching</h2>
<p>XML (and HTML) can not be fully specified with a context-free grammar. Matching the start and end tag names requires a context-sensitive grammar.
</p>
<p>However, a context-free grammar can be used for the XML syntax without the tag match check. Verification that the tag names match can be done separately after the parser has matched the nested element structure.
</p>
<p>Here is the essence of the XML element grammar:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(3)' >Example 3</button>
    <button onClick='gritbox.RUN(3)'>RUN</button>
  </div>
  <textarea id='gritbox-src-3' style="width:49%" rows=10>const html = grit`
    element = '<' tag '>' content '</' tag '>'
    content = (element / text)*
    tag     = \w+
    text    = [^<]*
`;

const test = `<i>xx<b>yy</b>zz</i>`;

write( html.parse(test) );</textarea>
  <textarea id='gritbox-dst-3' style="width:49%" rows=10></textarea>
  
      <textarea id='gritbox-eg-3-0' hidden>const html = grit`
    element = '<' tag '>' content '</' tag '>'
    content = (element / text)*
    tag     = \w+
    text    = [^<]*
`;

const test = `<i>xx<b>yy</b>zz</i>`;

write( html.parse(test) );</textarea>
  <script>gritbox.RUN(3)</script><br>

<p>The example shows correctly matching tags, but this grammar will match any tag names.
</p>
<p>An extended regex with back matching can not be used here because the <code>content</code> between the tags can contain nested elements, and a regular expression can not handle that.
</p>
<p>Action functions can be added to the grammar to ensure that the tags match:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(4)' >Example 4</button>
    <button onClick='gritbox.RUN(4)'>RUN</button>
  </div>
  <textarea id='gritbox-src-4' style="width:49%" rows=20>const html = grit`
    element = '<' tag1 '>' content '</' tag2 '>'
    content = (element / text)*
    tag1    = \w+  : save
    tag2    = \w+  : match
    text    = [^<]*
`;

html.tags = [];

html.actions = {
    save: (tag) => 
        html.tags.push(tag),
    match: (tag) => 
        html.tags.pop() == tag || null
}

const test = `<i>xx<b>yy</i>zz</b>`;

write( html.parse(test) );</textarea>
  <textarea id='gritbox-dst-4' style="width:49%" rows=20></textarea>
  
      <textarea id='gritbox-eg-4-0' hidden>const html = grit`
    element = '<' tag1 '>' content '</' tag2 '>'
    content = (element / text)*
    tag1    = \w+  : save
    tag2    = \w+  : match
    text    = [^<]*
`;

html.tags = [];

html.actions = {
    save: (tag) => 
        html.tags.push(tag),
    match: (tag) => 
        html.tags.pop() == tag || null
}

const test = `<i>xx<b>yy</i>zz</b>`;

write( html.parse(test) );</textarea>
  <script>gritbox.RUN(4)</script><br>

<p>The tags need to be pushed onto a stack to allow the content to contain nested elements.
</p>
<h2>Nested Indentation</h2>
<p>Nested indentation syntax, as used in Python, has a block structure based on lines with the same inset. The inset on the first line in a block can be any number of space characters, and subsequent lines in the same block must be inset with the same number of space characters. 
</p>
<p>For example:
</p>
<pre class="code"><code>if x:
    if y:
        print("x & y")
    if z:
        print("x & z")
print("x done...")</code></pre>
<p>A sketch for the grammar of this block structure:
</p>
<pre class="code"><code>block  = indent line inlay* undent
inlay  = body / block
body   = inset line</code></pre>
<p>The first line of a block can have any <code>indent</code>, and subsequent lines in the block must have the same <code>inset</code>. A block nested inside an outer block must have a larger <code>inset</code>. In other words:
</p>
<pre class="code"><code>indent > parent.indent
inset = parent.indent </code></pre>
<p>These constraints can be enforced in action functions:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(5)' >Example 5</button>
    <button onClick='gritbox.RUN(5)'>RUN</button>
  </div>
  <textarea id='gritbox-src-5' style="width:49%" rows=39>const nest = grit`
    block  = indent line inlay* undent
    inlay  = body / block
    body   = inset line
    indent = [ ]* : push
    inset  = [ ]* : match
    undent = ''   : pop
    line   = [^\n\r]* nl
    nl     = \n|\r\n?|$
`;

nest.inset = -1;
nest.stack = [];

nest.actions = {
    block: ([_,ln,lns]) => [ln,lns],
    body: ([_,ln]) => ln,
    push: (x) => 
        x.length > nest.inset?
            nest.stack.push(nest.inset) 
            && (nest.inset = x.length)
            : null,
    pop: () => 
        nest.inset = nest.stack.pop(),
    match: (x) =>
        x.length == nest.inset? x : null,
    line: ([ln,_]) => ln
};

const test = `
if x:
    if y:
        print("x & y")
    if z:
        print("x & z")
print("x done...")
`;

print(nest.parse(test));</textarea>
  <textarea id='gritbox-dst-5' style="width:49%" rows=39></textarea>
  
      <textarea id='gritbox-eg-5-0' hidden>const nest = grit`
    block  = indent line inlay* undent
    inlay  = body / block
    body   = inset line
    indent = [ ]* : push
    inset  = [ ]* : match
    undent = ''   : pop
    line   = [^\n\r]* nl
    nl     = \n|\r\n?|$
`;

nest.inset = -1;
nest.stack = [];

nest.actions = {
    block: ([_,ln,lns]) => [ln,lns],
    body: ([_,ln]) => ln,
    push: (x) => 
        x.length > nest.inset?
            nest.stack.push(nest.inset) 
            && (nest.inset = x.length)
            : null,
    pop: () => 
        nest.inset = nest.stack.pop(),
    match: (x) =>
        x.length == nest.inset? x : null,
    line: ([ln,_]) => ln
};

const test = `
if x:
    if y:
        print("x & y")
    if z:
        print("x & z")
print("x done...")
`;

print(nest.parse(test));</textarea>
  <script>gritbox.RUN(5)</script><br>

<p>The insets could be extended to allow tabs, but trying to mix tabs with spaces should be avoided. 
</p>
<h2>Context Sensitive Grammars</h2>
<p>A classic academic test case that requires a context-sensitive grammar is A<sup>n</sup>B<sup>n</sup>C<sup>n</sup> where the number of As and Bs and Cs must be the same. This is not possible with context-free grammar rules alone, but it is very simple with the help of an action function:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(6)' >Example 6</button>
    <button onClick='gritbox.RUN(6)'>RUN</button>
  </div>
  <textarea id='gritbox-src-6' style="width:49%" rows=13>const abc = grit`
    abc = 'a'+ 'b'+ 'c'+  : all_eq
`;

abc.actions = {
    all_eq: ([as,bs,cs]) => 
        (as.length == bs.length) &&
        (bs.length == cs.length) || null
}

const test = `aaabbbccc`;

write( abc.parse(test) );</textarea>
  <textarea id='gritbox-dst-6' style="width:49%" rows=13></textarea>
  
      <textarea id='gritbox-eg-6-0' hidden>const abc = grit`
    abc = 'a'+ 'b'+ 'c'+  : all_eq
`;

abc.actions = {
    all_eq: ([as,bs,cs]) => 
        (as.length == bs.length) &&
        (bs.length == cs.length) || null
}

const test = `aaabbbccc`;

write( abc.parse(test) );</textarea>
  <script>gritbox.RUN(6)</script><br>

<p>From an academic perspective this is cheating! It is too simple.
</p>
<p>The point is that an action function can do anything, so solving the problem this way opens up Pandoras box, any program code could be used to do anything.
</p>
<p>However, in practice being able to extend the grammar rules on occasion may be the only practical solution. In this case the grammar rule extension is clear and obvious. 
</p>
<p>Formal grammar rules to solve this problem are usually very complex and hard to understand.  
</p>
<p>As it happens a PEG grammar can go a little beyond a context-free grammar, so it is possible to specify the A<sup>n</sup>B<sup>n</sup>C<sup>n</sup> grammar, but it not is not a very attractive solution:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(7)' >Example 7</button>
    <button onClick='gritbox.RUN(7)'>RUN</button>
  </div>
  <textarea id='gritbox-src-7' style="width:49%" rows=10>const abc = grit`
    abc = &(A 'c') 'a'+ B end
    A   = 'a' A? 'b'
    B   = 'b' B? 'c'
    end = ![\s\S]
`;

const test = `aaabbbccc`;

write( abc.parse(test) );</textarea>
  <textarea id='gritbox-dst-7' style="width:49%" rows=10></textarea>
  
      <textarea id='gritbox-eg-7-0' hidden>const abc = grit`
    abc = &(A 'c') 'a'+ B end
    A   = 'a' A? 'b'
    B   = 'b' B? 'c'
    end = ![\s\S]
`;

const test = `aaabbbccc`;

write( abc.parse(test) );</textarea>
  <script>gritbox.RUN(7)</script><br>

<p>The <code>A</code> rule will match an equal number of <code>a</code>&rsquo;s and <code>b</code>&rsquo;s, and the <code>&</code> operator will check that this is true, but it will not consume any input. All the <code>a</code>&rsquo;s can be matched now, and the <code>B</code> rule ensures that the same number of <code>b</code>&rsquo;s and <code>c</code>&rsquo;s are matched.
</p>
<p>In general there is no easy way to specify a context-sensitive grammar. Attempts to push grammar rules beyond a context-free grammar have ended up with rules that are very complex and difficult to understand. The <a href='https://www.amazon.ca/Adapting-Babel-Adaptivity-Context-Sensitivity-Parsing/dp/1505652723'>§-calculus</a> is a modern formal grammar system designed to tackle the very difficult problems of context-sensitive languages (Quinn Tyler Jackson, Adapting to Babel, Adaptivity & Context-Sensitivity in Parsing, 2006).
</p>

<h2>Conclusion</h2>
<p>Almost all practical computer languages and formats can be specified with a context-free grammar, but there are a few important exceptions that need to be dealt with in practice.
</p>
<p>A PEG grammar is simpler than a traditional context-free grammar, but it can specify any unambiguous context-free language (and some context-sensitive grammars). It is deterministic, so it can not handle the syntactic ambiguity that a natural (human) language may require. For computer applications ambiguity is always undesirable and never required, so a PEG grammar is a very neat solution.
</p>
<p>The Grit grammar rules are based on PEG logic, and they allow regular expressions to be used directly as components in the grammar rules. This allows the grammar rules to specify an efficient parser for any non-ambiguous context-free language.
</p>
<p>Action functions can be used for the exceptions that do not fit into a context-free grammar. They can be used to extend the rules. Action functions allow the full power of the host programing language to be employed, so they are dangerous and could be abused. However, using action functions to cope with awkward grammar features can be kept simple and easy to understand. They are a very practical solution.
</p>


</body>
</html>
