<!DOCTYPE HTML>
<html>
<head>
<meta lang=en charset="UTF-8">
<script>if (window.moko) alert("!!! moko global name conflict....");
window.moko = {}
</script>

<script>
// Grammar Parser -- an evolution of Grit.

// See docs at: https://github.com/pcanz/grammar-parser

/*	The MIT License (MIT)
 *
 *	Copyright (c) 2015,2016,2017,2018,2019 Peter Cashin
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files(the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 *	furnished to do so, subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included
 *	in all copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 *	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

;(function() { // module name-space wrapper -- see the end of this file...

/* -- grammar-rule grammar ---------------------------------------

    grammar = rule+
    rule    = name "=" expr ws act?

    expr    = seq ("/" seq)*
    seq     = (ws [&!]? term [*+?]?)*
    term    = ref / quote / regex / group

    name    = ws \w+
    ref     = name !\s*=
    group   = "(" expr ")"

    quote   = '"' [^"]* '"' / "'" [^']* "'"
    regex   = &[[\\] (chs / par / misc)+
    chs     = [\[] ([^\]\\]* ([\\][^])?)+ [\]]
    par     = [(] ([^()]* par?)* [)]
    misc    = [^[()\s]+

    act     = ":" lines
    lines   = line (\s* !\S+\s*= line)*
    line    = [^\n\r]* 
    ws      = \s*  
*/

// -- parser code for grit_rules --------------------------------------

// The parser is a byte-code style interpreter, but encodes
// instructions an array data structure with string values.

/* parser instruction codes:

    ["^", "regex"]      match regexp
    ["=", rule]         call rule by name.
    [",", a, b, c, ...] sequence of instruction codes, all to succeed.
    ["/", a, b, c, ...] altrnatives, first to succeed.
    ["+", x]            matches one or more x, or fails.
    ["*", x]            matches any number of x, none matches "".
    ["?", x]            optional match: x / ""
    ["&", x]            lookahead: "" if x matches, else fails.
    ["!", x]            negation: fails if x matches, else "".
 
    The parser compiles rule names to rule indexes on the fly, and also
    compiles regexp's on the fly (to keep the code simple, and portable).

    The parser code can be exported as JSON.
*/

const grit_code = [
    {   name: "grammar", // grammar = rule+
        code: ["+",["=","rule"]] },

    {   name: "rule", // rule = name "=" expr ws act?
        code: [",",["=","name"],["^","\\s*="],["=","expr"],
                        ["=", "ws"],["?",["=","act"]]] },

    {   name: "expr", // expr = seq ("/" seq)*
        code: [",",["=","seq"],["*",[",",["^","\\s*/"],["=","seq"]]]] },

    {   // seq = (ws [&!]? term [*+?]?)*
        name: "seq",
        code: ["*",[",",["=","ws"],["^","[&!]?"],["=","term"],["^","[*+?]?"]]] },

    {   name: "term", // term = ref / quote/ regex / group
        code: ["/",["=","ref"],["=","quote"],["=","regex"],["=","group"]] },

    {   name: "name", // name = ws \w+
        code: [",",["^","[\\s]*"],["^","[\\w]+"]] },

    {   name: "ref", // ref = name !\s*=
        code: [",",["=","name"],["!",["^","[\\s]*="]]] },

    {   name: "quote", // quote = '"' [^"]* '"' / "'" [^']* "'"
        code: ["^","\\s*((?:'[^']*'|\"[^\"]*\")[\\w]*)"] },

    {   name: "regex", // regex = &[[\\] (chs / par / misc)+
        code: [",",["&",["^","[[\\\\]"]],["+",["/",["=","chs"],["=","par"],["=","misc"]]]] },

    {   name: "chs", // [\[] ([^\]\\]* ([\\][^])?)+ [\]]
        code: ["^","[[](?:[^\\]\\\\]*(?:[\\\\][^])?)+[\\]]"] },

    {   name: "par", // par = [(] ([^()]* par?)* [)]
        code: [",",["^","[(]"],["*",[",",["^","[^()]*"],["?",["=","par"]]]],["^","[)]"]] },

    {   name: "misc", // [^[()\s]+
        code: ["^","[^[()\\s]+"] },

    {   name: "group", // group = "(" expr ")"
        code: [",",["^","\\s*\\("],["=","expr"],["^","\\s*\\)"]] },

    {   name: "act", // act = ":" lines
        code: [",",["^","\\s*:"],["^","[^\\n\\r]*"], // line = [^\n\r]*
                ["*",[",",["^","\\s*"],["!",["^","\\S+\\s*="]],
                          ["^","[^\\n\\r]*"]]]] },

    {   name: "ws", // ws = \s* 
        code: ["^","\\s*"] }
];

resolve_code(grit_code); // maps names to indexes & compiles regexes

// -- compile peg rules into parser instruction codes --------------------

const grit_actions = { // semantic actions for parse tree nodes...

    // grammar = rule+
    "grammar": (rs) => rs,

    // rule = name "=" expr ws act?
    "rule": ([name, _, code, ws, action]) => {
        return {name, code, action};
    },

    // expr = seq ("/" seq)*
    "expr": ([seq, alts]) => {
        if (alts.length === 0) {
            return seq;
        } else {
            var seqs = alts.map(([_, seq]) => seq)
            return ["/", seq, ...seqs];
        }
    },

    // seq = (ws [&!]? term [*+?]?)*
    "seq": (xs) => {
        var ts = xs.map(([ws, pred, term, rep]) => {
            if (rep) { term = [rep, term]; }
            if (pred) { term = [pred, term];}
            return term;
        })
        if (ts.length === 1) return ts[0];
        return [",", ...ts];
    },

    // term = ref / match / group
    "term": (x) => x,

    // name = ws \w+
    "name": ([_, name]) => name,

    // ref = name !\s*=
    "ref":  ([name, _]) => ["=", name, null],

    // group = "(" expr ")"
    "group": ([_, expr]) => expr,

    // quote = '"' [^"]* '"' / "'" [^']* "'"
    "quote": (str) => { // quote => regex: \s*("...")\s*
        if (str.length === 2) { // empty quotes..
            return (str[0] === "'")? ["^","\uFFFF?"] : ["^","\\s*(\uFFFF?)"];
        }
        qt = str.slice(1,-1);
        if (str[0] === "'") return ["^",esc_regex(qt)];
        return ["^","\\s*("+esc_regex(qt)+")\\s*"];
    },

    // regex   = &[[\\] (chs / par / misc)*
    "regex": ([_, rs]) => ["^", rs.join('')],

    // par = [(] ([^()]* par?)* [)]
    "par": ([lp, ps, rp]) => { // par? => p, will be already done..
        var xps = ps.map(([x, p]) => p? x+p : x);
        return lp + xps.join('') + rp; 
    },

    // act = ":" lines
    "act": ([_, line, lines]) => {
        return string([line, lines]);
    },

    // ws = \s*
    "ws": (s) => s

} // grit_actions

function esc_regex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function rules_map(code) {
    return code.reduce((rm, rule, idx) => {
        rm[rule.name] = idx; return rm; }, {});
}

function resolve_code(code) {
    var name_idx = rules_map(code);

    function resolve (op) {
        if (!Array.isArray(op)) return op;
        if (op[0] === "^") {
            op[2] = op[2] || new RegExp(op[1],"uy"); // unicode sticky flags
            return op;
        }
        if (op[0] === "=") {
            op[2] = name_idx[op[1]];
            if (!op[2] && op[2]!==0) {
                throw new Error("*** missing rule '"+op[1]+"' ... ")
            }
            return op;
        }
        return op.map((x) => resolve(x));
    }
    var coded = code.map((rule) => {
        return resolve(rule.code);
    });

    return code;
}


// -- built-in semantic actions ---------------------------------------------


const std_actions = {

    xfy: (result) => { // a (op b)* => [op,x,y]
        function xfy(x, ys) {
            if (ys.length === 0) return x;
            var [op, y] = ys[0];
            return [op, x, xfy(y, ys.slice(1))]
        }
        var [x, ys] = result;
        return xfy(x, ys);
    },
 
    yfx: (result) => { // a (op b)* => [op,y,x]
        var [a, bs] = result;
        return bs.reduce((y, [op, b]) => [op, y, b], a)
    },

    xfx: (result) => { // a (op b)* => [a,op,b,op,c,...]
        var [a, bs] = result;
        return bs.reduce((y, b) => y.concat(b), [a])
    },

    yfy: (result) => { // a (_ b)* => [a,b,c,...]
        var [a, bs] = result;
        return bs.reduce((y, [_, b]) => y.concat(b), [a]);
    },

    flatten: (xs) => flatten(xs),

    string: (xs) => string(xs),

    number: (xs) => number(xs),

    x: (result) => result,
    n: (result) => Number(result),
    _: (result) => ""

}

function flatten(xs) {
    return Array.isArray(xs)?
        xs.reduce((y,x) => y.concat(flatten(x)),[]) : xs;
}

function string(xs) {
    return Array.isArray(xs)? flatten(xs).join('') : xs;
}

function number(xs) {
    return Number(string(xs));
}

// -- parser -- string-code interpreter ------------------------------------

function parser (code, input, actions={}, options={}) {
    var pos = 0;
    var inRule = "start"; // current rule trace 
    var ruleStack = [];
    var maxPos = 0; // high water mark
    var maxRule= ""; // inRule at maxPos
    var runOps = 0;
    var maxOps = 10000; // run away recursion check

    if (!code) {
        return report("missing grammar rule code...");
    }

    var start_name = code[0].name;
    var start = ["=", start_name, 0];

    if (typeof input !== "string") {
        try {
            input = String.raw(input);
        } catch(err) {
            input = '';
            return report("input is not a string...");
        }
    }

    if (typeof actions === 'function') {
        actions = { "?": actions } // catch all
    }

    if (options.trace) console.log("trace", start_name)

    var result = run(start); // run the parser engine...

    if (result === null) {
        return report("failed");
    }
    if (pos < input.length && !input.slice(pos).match(/^\s+$/)) {
        if (options.replay) replay();
        return report("fell short");
    }
    return result;

    // -- code engine -------------------------------------------

    function run(op) {

        if (runOps += 1 > maxOps) {
            return report("run away recursion...");
        }

        switch (op[0]) {

        case '^': // ["^", src, regex]
            var regex = op[2]; 
            regex.lastIndex = pos; // using regex.y sticky flag
            var mx = regex.exec(input);
            var trace = options.trace;
            if (trace) {
                if (typeof trace !== "string" || trace === inRule) {
                    var span = pos;
                    span += mx? ".."+(pos+mx[0].length) : ""
                    var match = mx? "=>"+mx[0] : "!";
                    console.log(span,inRule,regex,match);
                }
            }
            if (!mx) return null;
            pos += mx[0].length;
            if (pos > maxPos) { 
                maxPos = pos; 
                maxRule = inRule;
            }
            return mx[1]||mx[0]; // used to skip white-space prefix

        case '=': // ["=", name, idx]
            var idx = op[2];
            var rule = code[idx];
            if (!rule) { // bad grammar ...
                return report("missing rule "+idx+": '"+op[1]+"' ...");
            }
            ruleStack.push(inRule)
            inRule = op[1];
            var start = pos;
            var result = run(rule.code);
            inRule = ruleStack.pop();
            if (result === null) {
                pos = start;
                return null;
            }
            var {name, action} = rule;
            var val = run_action(result, {name, action, pos, input, posit});
            if (val !== null) return val;
            pos = start; // fail
            return null;

        case ',': // [",", ..., seq, ... ]
            var start = pos;
            var res = [];
            var i = 1;
                while (i < op.length) {
                var temp = run(op[i]);
                if (temp === null) {
                    pos = start;
                    return null;
                }
                res.push(temp);
                i += 1;
            }
            return res;

        case '/': // ["/", ..., alt, ... ]
            var start = pos;
            var res = null; // fail if no alt
            var i = 1;
            while (i < op.length) {
                res = run(op[i]);
                if (res !== null && pos > start) {
                    return res;
                }
                pos = start;
                i += 1;
            }
            return res;

        case '*': // ["*", op]
            var start = pos;
            var temp = run(op[1]);
            if (temp === null) return [];
            var res = [temp];
            while (pos > start) {
                start = pos;
                temp = run(op[1]);
                if (temp === null) break;
                res.push(temp);
            }
            return res;

        case '+': // ["+", op]
            var start = pos;
            var temp = run(op[1]);
            if (temp === null) return null;
            var res = [temp];
            while (pos > start) {
                start = pos;
                temp = run(op[1]);
                if (temp === null) break;
                res.push(temp);
            }
            return res;

        case '?': // ["?", op]
            var res = run(op[1])
            if (res === null) return "";
            return res;

        case '!': // ["!", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res === null) return "";
            return null;

        case '&': // ["&", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res !== null) return "";
            return null;

        default: // should never happen...
		    throw new Error("*** Undefined parse code op: "+JSON.stringify(op));
        }
    } // run

    function report(msg) {
        var at = pos + (maxPos>pos? ".."+maxPos : "") + " of " + input.length;
        var pre = pos<16? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var show = pre + input.slice(pos,pos+40);
        show = show.replace(/[\x00-\x1f]/g,"¬")
        if (input.length > pos+40) show += "..."
        var cursor = "";
        for (var i=0; i < pre.length; i+=1) cursor += " ";
        cursor += "^";
        var max = maxPos-pos>40? 42 : maxPos;
        for (var i=pos+1; i < max; i+=1) cursor += " ";
        cursor += "^";
        var report = "*** grammar '"+start_name+"' parse "+msg+
                    " after: '"+maxRule+"' at: "+at+"\n"+
                        show+"\n"+cursor;
        if (!options || (!options.silent && !options.console)) {
            throw new Error(report);
        } else if (options.console && !options.silent) {
            console.log(report);
        } else { // silent reporting...
            options.report = report;
        }
        return null;
    }

    function replay() {
        try {
            parser(code, input, actions, {trace:true});
        } catch(err) {
            // console.log(err);
        }
    }

    function posit(n) {
        console.log("posit", pos, n);
        pos = n;
    }

    function run_action(result, parse) {
        var fn = null;
        var {name, action} = parse; // {name, action, pos, input, posit}
        if (action) {
            var ax = action.match(/^\s*(\S+)/);
            act = ax? ax[1] : "";
            fn = actions[act] || std_actions[act];
            if (!fn) { // synthetic action: _x_ etc..
                if (act.match(/^[_x]+$/) && Array.isArray(result)) {
                    var res = [];
                    result.forEach((x, i) => {
                        var k = act[i];
                        if (k === "x") res.push(x);
                    });
                    if (res.length === 1) return res[0];
                    return res;
                }            
            }
        } // action
        fn = fn || actions[name] || actions["?"];
        if (fn) {
            try {
                return fn(result, parse);
            } catch(err) {
                report("Bad action for '"+name+"':\n"+err);
            }
        }
        return result // [name, result] // default result..
    }


} // parser


// -- grammar_parser --------------------------------------------------------

function grammar_parser (grammar, actions) {

    let code = parser(grit_code, grammar, grit_actions)

    if (!code) return null;
    
    resolve_code(code);

    function parse(input, options) {
        return parser(code, input, this.actions, options);
    };

    return {parse, grammar, actions, code};
}

// module.exports = grammar_parser;
// expose grammar_parser ----------------------------------------------

if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = grammar_parser;
} else if (typeof define === 'function' && define.amd) {
    define(function() { return grammar_parser; });
} else {
    this.grammar_parser = grammar_parser;
}

}).call(function() {
return this || (typeof window !== 'undefined' ? window : global);
}()); // outer funtion name-space wrapper

;
</script> 
<script type="text/javascript">
    var moko = window.moko || (window.moko = {});
    moko.sandbox = {};
    moko.sandbox.write = (txt) => res += JSON.stringify(txt)
    var sandbox = moko.sandbox
    sandbox.RESET = (i) => {
	    var src = sandbox.textarea_src(i)
        var example = sandbox.example(i, 0)
	    src.value = example.value
	    sandbox.RUN(i);
    }
    sandbox.RUN = (i) => {
        var src = sandbox.textarea_src(i)
        var dst = sandbox.textarea_dst(i)
        var res = "";
        try {
            var verbs = {
                // grit: window.Grit,
                grammar_parser: window.grammar_parser, // new grit,
                grit: window.grammar_parser, // grit 3.x
                write: (...args) => {
                    res += args.map((arg)=>
                        JSON.stringify(arg)).join(' ')+"\r\n\r\n";
                },
                print: (...args) => {
                    res += args.map((arg)=>
                        JSON.stringify(arg,null,2)).join(' ')+"\r\n\r\n";
                }    
            }
            var keys = Object.keys(verbs);
            var vals = keys.map((k)=> verbs[k])
            var fn = new Function(...keys, src.value)
            fn(...vals);
        } catch(err) {
            res = err
        }
        dst.value = res;
    }
    sandbox.SELECT = (i) => {
        var x = document.getElementById("sandbox-select-"+i).value;
        var example = sandbox.example(i, x-1)
        var src = sandbox.textarea_src(i)
        src.value = example.value
        sandbox.RUN(i);
    }
    sandbox.textarea_src = (i) => document.getElementById('sandbox-src-'+i);
    sandbox.textarea_dst = (i) => document.getElementById('sandbox-dst-'+i);
    sandbox.example = (i, n) => document.getElementById('sandbox-eg-'+i+'-'+n);
</script>
<style>
textarea {font-family: monospace; font-size:10pt; background:whitesmoke;}
</style>
<style>
td.demo-1, .demo-eg { margin-right:10pt; background:whitesmoke;
                       padding: 0pt 10pt; }
td.demo-2 { padding: 0pt 10pt; }
</style>

</head>
<body>
<h1><span id="sect-Grammar Parsers"></span>Grammar Parsers</h1>
<p>Regular expressions are a standard tool in every programmers tool-box. But grammar rules are rarley used, they seem to be reserved for specialists such as language designers and compiler writers.</p>
<p>This is a pity, since grammar rules make nice specifications, and they can be simpler and more expressive than regular expressions.</p>
<p>The traditional approach is to start with a grammar as a specification. A parser may be hand coded to match the grammar specification. Or special tools may be used to compile a suitably modified version of the grammar specification, and generate program code for a parser.</p>
<p>Here we take a different approach, using grammar rules that can be directly executed in a program, in much the same way as regular expressions. These grammar rules are both simpler and more powerful than using bare regular expressions. They provide an easy way for a programmer to organize and manage their use of regular expresssions.</p>
<p>We will use a form of <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG</a> (Parser Expression Grammar) rules, which can contain regular expression elements. The grammar rules can name other grammar rules as component parts. This will be explained shortly, but the general idea should be reasonably obvious.</p>
<p>Using PEG rules eliminates the need for a pre-parse <a href="https://en.wikipedia.org/wiki/Lexical_analysis">lexer</a> which traditional grammar tools employ. The PEG grammar rules directly recognize (pattern match) input text strings.</p>
<p>The grammar rules can be used in almost any programming language. We will use JavaScript here in order to show running examples, and to compare grammar rules with regular expressions. To do that we will need to introduce a few programming language details, but the grammar rules themselves are independent of the host programming language.</p>
<h2><span id="sect-A First Example"></span>A First Example</h2>
<p>The first example is to match a date format, such as &ldquo;3/4/2019&rdquo;, which some people see as the 3rd of April, and others as the 4th of March. If we ignore the semantics, the syntax is almost trivial, and our first task is simply to match the pattern in this date format.</p>
<p>First we will look at a standard regular expression to match a date pattern:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-1" onchange="sandbox.SELECT(1)">
      
      <option value='1'>Example 1.1</option>
      <option value='2'>Example 1.2</option>
      <option value='3'>Example 1.3</option>
      </select>
    <button onClick='sandbox.RUN(1)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-1' style="width:49%" rows=7>const date_regex = new RegExp(
  `(\\d+)/(\\d+)/(\\d+)`
);

var date_match = date_regex.exec("3/4/2019");

write(date_match); // ===></textarea>
  <textarea id='sandbox-dst-1' style="width:49%" rows=7></textarea>
  
      <textarea id='sandbox-eg-1-0' hidden>const date_regex = new RegExp(
  `(\\d+)/(\\d+)/(\\d+)`
);

var date_match = date_regex.exec("3/4/2019");

write(date_match); // ===></textarea>
      <textarea id='sandbox-eg-1-1' hidden>const date_rule = String.raw`(\d+)/(\d+)/(\d+)`;

const date_regex = new RegExp(date_rule);

var date_match = date_regex.exec("3/4/2019");

write(date_match); // ===></textarea>
      <textarea id='sandbox-eg-1-2' hidden>const date_regex = /(\d+)\/(\d+)\/(\d+)/;

var date_match = date_regex.exec("3/4/2019");

write(date_match); // ===>

</textarea>
  <script>sandbox.RUN(1)</script><br>

<p>In JavaScript the regular expression could of course be written as:</p>
<pre class='demo-eg'>    const date_regex = /(\d+)\/(\d+)\/(\d+)/;
</pre>
<p>The regular expression has been written as a text string so that it is directly comparable with this grammar rule version:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-2" onchange="sandbox.SELECT(2)">
      
      <option value='1'>Example 2.1</option>
      <option value='2'>Example 2.2</option>
      <option value='3'>Example 2.3</option>
      </select>
    <button onClick='sandbox.RUN(2)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-2' style="width:49%" rows=9>const date_peg = grit(`
    date = \\d+ '/' \\d+ '/' \\d+
`);

var date_match = date_peg.parse("3/4/2019");

write(date_match); // ===></textarea>
  <textarea id='sandbox-dst-2' style="width:49%" rows=9></textarea>
  
      <textarea id='sandbox-eg-2-0' hidden>const date_peg = grit(`
    date = \\d+ '/' \\d+ '/' \\d+
`);

var date_match = date_peg.parse("3/4/2019");

write(date_match); // ===></textarea>
      <textarea id='sandbox-eg-2-1' hidden>const date_grammar = String.raw`
    date = \d+ '/' \d+ '/' \d+
`;

const date_peg = grit(date_grammar);

var date_match = date_peg.parse("3/4/2019");

write(date_match); // ===></textarea>
      <textarea id='sandbox-eg-2-2' hidden>const date_peg = grit`
    date = \d+ '/' \d+ '/' \d+
`;

var date_match = date_peg.parse("3/4/2019");

write(date_match); // ===>

</textarea>
  <script>sandbox.RUN(2)</script><br>

<p>The <code>grit</code> function corresponds to the <code>RegExp</code> object, it is a function that takes the grammar rules as input and returns a parser function. The source code for the <code>grit</code> grammar parser can be found at: <a href="https://github.com/pcanz/grammar-parser">https://github.com/pcanz/grammar-parser</a></p>
<p>The date grammar rule is quite similar to the date regular expression rule, the big difference is that the grammar rule has a name (before the <code>=</code> symbol), and the rule uses white-space to separate the component parts (extra white-space is insignificant).</p>
<pre class='demo-eg'>    regular expression:  (\d+)/(\d+)/(\d+)
    grammar rule:        date = \d+ '/' \d+ '/' \d+
</pre>
<p>The component parts can include a quoted string for a literal match, or a <em>regex</em> regular expression. A regex component uses the standard regular expression syntax for a back-slash character class, or for a character-set in square brackets (not used in this example).</p>
<p>The first example was written so that the grammar rule version corresponded closely to the regular expression version. But grammar rules really come into their own when the component parts are split out into separate named rules:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-3" onchange="sandbox.SELECT(3)">
      
      <option value='1'>Example 3.1</option>
      <option value='2'>Example 3.2</option>
      <option value='3'>Example 3.3</option>
      </select>
    <button onClick='sandbox.RUN(3)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-3' style="width:49%" rows=11>const mdy = grit`
    date  = month '/' day '/' year
    day   = \d+
    month = \d+
    year  = \d+
`;

var date_match = mdy.parse("3/4/2019")

write(date_match)</textarea>
  <textarea id='sandbox-dst-3' style="width:49%" rows=11></textarea>
  
      <textarea id='sandbox-eg-3-0' hidden>const mdy = grit`
    date  = month '/' day '/' year
    day   = \d+
    month = \d+
    year  = \d+
`;

var date_match = mdy.parse("3/4/2019")

write(date_match)</textarea>
      <textarea id='sandbox-eg-3-1' hidden>const mdy = grit`
    date  = month '/' day '/' year
    day   = \d{1,2}
    month = \d{1,2}
    year  = \d{4}
`;

var date_match = mdy.parse("3/4/2019")

write(date_match)</textarea>
      <textarea id='sandbox-eg-3-2' hidden>const mdy = grit`
    date  = month '/' day '/' year
    day   = [3][0-1] / [1-2][0-9] / [1-9]
    month = [1][0-2]|[1-9]
    year  = [1-2]\d{3}
`;

var date_match = mdy.parse("3/4/2019")

write(date_match)
</textarea>
  <script>sandbox.RUN(3)</script><br>

<p>In this example the <code>grit</code> function has been used as a tag funtion on a JavaScript template string. This is slightly easier to write and avoids the need to escape the <code>\</code> back-slash characters.</p>
<p>This version matches exactly the same syntax as the previous examples, but the grammar rule names show the semantic intent for this grammar. The parser function has been given a short name <code>mdy</code> (month-day-year) to stand for the type of text it represents, but it could be given a longer name such as <code>date_parser</code>.</p>
<p>The grammar rules are a text string, and the <code>grit</code> function returns a parser function. The result of applying the parser function to an input text string is, by default, an array of string values (a simple JSON data structure).</p>
<p>The date grammar in this example has has been kept as simple as possible to illustrate how things work. In practice a more accurate date grammar could be used, for example it could require that the year has exactly four digits and the month and day have only one or two digits (see example 3.2).</p>
<p>For a slightly larger example we will look at parsing a URI into its component parts. Of course there are library parser functions to decode a URI, and these are the best way to do this particular job. The URI format simply provides a familar example in order to demonstrate the grammar rule approach.</p>
<p>First using a regular expression:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-4" onchange="sandbox.SELECT(4)">
      
      <option value='1'>Example 4.1</option>
      <option value='2'>Example 4.2</option>
      </select>
    <button onClick='sandbox.RUN(4)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-4' style="width:49%" rows=11>const uri = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

var matched = uri.exec(
  "https://host/path/file/foo.txt"
);

write(matched);</textarea>
  <textarea id='sandbox-dst-4' style="width:49%" rows=11></textarea>
  
      <textarea id='sandbox-eg-4-0' hidden>const uri = /^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;

var matched = uri.exec(
  "https://host/path/file/foo.txt"
);

write(matched);</textarea>
      <textarea id='sandbox-eg-4-1' hidden>const uri_regex = String.raw
`^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?`;

const uri = new RegExp(uri_regex);

var input = "https://host/path/file/foo.txt";

var matched = uri.exec(input);

write(matched);
</textarea>
  <script>sandbox.RUN(4)</script><br>

<p>Now using a grammar:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-5" onchange="sandbox.SELECT(5)">
      
      <option value='1'>Example 5.1</option>
      <option value='2'>Example 5.2</option>
      </select>
    <button onClick='sandbox.RUN(5)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-5' style="width:49%" rows=17>const uri = grit`
  uri    = scheme? host? path query? frag?
  scheme = [^:/?#]+ ':'
  host   = '//' [^/?#]*
  path   = [^?#]*
  query  = '?' [^#]*
  frag   = '#' [^\s]*
`;

var matched = uri.parse(
  "https://host/path/file/foo.txt"
);

write(matched);</textarea>
  <textarea id='sandbox-dst-5' style="width:49%" rows=17></textarea>
  
      <textarea id='sandbox-eg-5-0' hidden>const uri = grit`
  uri    = scheme? host? path query? frag?
  scheme = [^:/?#]+ ':'
  host   = '//' [^/?#]*
  path   = [^?#]*
  query  = '?' [^#]*
  frag   = '#' [^\s]*
`;

var matched = uri.parse(
  "https://host/path/file/foo.txt"
);

write(matched);</textarea>
      <textarea id='sandbox-eg-5-1' hidden>const uri_rules = String.raw`
  uri    = scheme? host? path query? frag?
  scheme = [^:/?#]+ ':'
  host   = '//' [^/?#]*
  path   = [^?#]*
  query  = '?' [^#]*
  frag   = '#' [^\s]*
`;

const uri = grit(uri_rules);

var input = "https://host/path/file/foo.txt";

var matched = uri.parse(input);

write(matched);
</textarea>
  <script>sandbox.RUN(5)</script><br>

<p>The grammar rules employ exactly the same regular expression, but split apart into named components. The advantage of using a grammar instead of a bare regular expression should now be clear. The grammar rules are simpler and easier to understand, and the parser can efficiently knit together the small regular expression components.</p>
<p>In general a regular expression can match anywhere is a longer input string, but a grammar rule parse always matches the full input string. It&rsquo;s like a regular expression that starts with <code>^</code> and ends with <code>$</code>. A larger grammar can of course arrange for one of its rules to match anywhere in an input string.</p>
<p>You can edit the examples and hit the <code>RUN</code> button to see what happens. For example, try adding a fragment to the input URI example. Or edit the grammar rules to play with them. If you replace the <code>write</code> with a <code>print</code> you will see the output in a different format. Examples 4.2 and 5.2 show the same examples expressed in a slightly different way.</p>
<h2><span id="sect-Grammar Rules"></span>Grammar Rules</h2>
<p>A grammar rule can be used to match a list with any number of items, whereas a regular expression is more restricted in that it must spell out each item to be matched.</p>
<p>For example, to match numbers in an addition list the best we can do with a regular expression is something like this:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-6" onchange="sandbox.SELECT(6)">
      
      <option value='1'>Example 6.1</option>
      <option value='2'>Example 6.2</option>
      </select>
    <button onClick='sandbox.RUN(6)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-6' style="width:49%" rows=6>const sum = /^(\d+)([+]\d+)?([+]\d+)?([+]\d+)?/;

var matched = sum.exec("1+2+3");

write(matched)</textarea>
  <textarea id='sandbox-dst-6' style="width:49%" rows=6></textarea>
  
      <textarea id='sandbox-eg-6-0' hidden>const sum = /^(\d+)([+]\d+)?([+]\d+)?([+]\d+)?/;

var matched = sum.exec("1+2+3");

write(matched)</textarea>
      <textarea id='sandbox-eg-6-1' hidden>const sum = /^(\d+)([+]\d+)*/;

var matched = sum.exec("1+2+3");

write(matched)
</textarea>
  <script>sandbox.RUN(6)</script><br>

<p>To use regular expressions for this kind of task really needs a program to repeatedly match a regular expression for a single item and build a list of the matched items. As we will see, a grammar rule can do that efficiently, without the need for any extra program code.</p>
<p>The result from the RegExp version is an array with the full match followed by the matched item (the bracket capture groups). A regular expression can only match one item at a time (see example 6.2)</p>
<p>A grammar rule can match a list of any number of items:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-7" onchange="sandbox.SELECT(7)">
      
      <option value='1'>Example 7.1</option>
      <option value='2'>Example 7.2</option>
      </select>
    <button onClick='sandbox.RUN(7)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-7' style="width:49%" rows=11>const sum = grit`
  sum = \d+ ("+" \d+)*
`;

var parsed = sum.parse( "1+2+3+4+5" );

write(parsed);</textarea>
  <textarea id='sandbox-dst-7' style="width:49%" rows=11></textarea>
  
      <textarea id='sandbox-eg-7-0' hidden>const sum = grit`
  sum = \d+ ("+" \d+)*
`;

var parsed = sum.parse( "1+2+3+4+5" );

write(parsed);</textarea>
      <textarea id='sandbox-eg-7-1' hidden>const sum = grit`
  sum = \d+ ("+" \d+)*
`;

var parsed = sum.parse( "1+2+3+4+5" );

const simplify = ([x, ys]) =>
    [x, ...ys.map(([_, y]) => y)];

write(simplify(parsed));
</textarea>
  <script>sandbox.RUN(7)</script><br>

<p>The result from a grammar-parser version is an array of the matched items, as a nested tree structure, which can be called a parse tree or an abstract syntax tree.</p>
<p>The parse tree results may look a little verbose, but the tree structure is quite easy for an application program to navigate and simplify (see example 7.2).</p>
<p>There are no special programming object types involved, the parse tree is a simple JSON data structure that can be implemented in almost any programming language.</p>
<p>Now for a more realistic example, reading a file of CSV (Comma Separated Variable) data, such as output from a spread-sheet application. The CSV format is simple enough, each line of text is a row in a table, using a comma separator between each column cell.</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-8" onchange="sandbox.SELECT(8)">
      
      <option value='1'>Example 8.1</option>
      <option value='2'>Example 8.2</option>
      </select>
    <button onClick='sandbox.RUN(8)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-8' style="width:49%" rows=11>const csv = grit`
    table = (row nl)*
    row   = cell (',' cell)*
    cell  = [^,\n\r]*
    nl    = \n / \r\n?
`;

var arr = csv.parse("a1,a2,a3\na2,b2,c2\n")

write(arr)</textarea>
  <textarea id='sandbox-dst-8' style="width:49%" rows=11></textarea>
  
      <textarea id='sandbox-eg-8-0' hidden>const csv = grit`
    table = (row nl)*
    row   = cell (',' cell)*
    cell  = [^,\n\r]*
    nl    = \n / \r\n?
`;

var arr = csv.parse("a1,a2,a3\na2,b2,c2\n")

write(arr)</textarea>
      <textarea id='sandbox-eg-8-1' hidden>const csv = grit`
    table = row+
    row   = nl* cell (',' cell)+
    cell  = [^,\n\r]*
    nl    = \n / \r\n?
`;

var arr = csv.parse("\na1,a2,a3\na2,b2,c2")

write(arr)
</textarea>
  <script>sandbox.RUN(8)</script><br>

<p>This is the first time we have seen a choice operator, using the <code>/</code> symbol. It serves the same purpose as the regex <code>|</code> choice operator, and it is used here for the mundane task of accepting different end-of-line conventions.</p>
<p>Notice that example 8.1 allows a table to be empty (no rows), and the rows can be empty (since cells can be empty). But it is quite strict about line breaks, every row must end with a line break, so there there must be one at the end. If there is one at the beginning it will be seen as an empty row.</p>
<p>Example 8.2 is a variation that requires a table to have at least one row with at least two cells in a row (but the cells can be empty). This version is more lenient on line breaks, it ignores optional leading or trailing line breaks, and blank lines between rows.</p>
<p>Grammar rules make very neat specifications, but they take practice. It is not always easy to see all the detailed implications as to exactly what they will and will not match.</p>
<p>The first CSV grammar is a little too simple, it needs to be extended to allow a cell field to contain a comma character. We will follow the RFC 4180 standard (Common Format and MIME Type for CSV Files  October 2005). In this format fields that contain a comma are put inside quote marks, and inside the quotes any other quote marks are doubled. Here are the extended grammar rules:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(9)' >Example 9</button>
    <button onClick='sandbox.RUN(9)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-9' style="width:49%" rows=22>const CSV_grammar = String.raw`
  csv     = nl* record+
  record  = fields nl*
  fields  = field (',' field)*
  field   = escaped / txt
  escaped = esc+
  esc     = ["] [^"]* ["]
  txt     = [^,"\n\r]*
  nl      = \n / \r\n?
`;

const CSV = grit(CSV_grammar);

var input = `
a,b,c
d,"e,""f",g
`;

var output = CSV.parse(input);

write(output);
</textarea>
  <textarea id='sandbox-dst-9' style="width:49%" rows=22></textarea>
  
      <textarea id='sandbox-eg-9-0' hidden>const CSV_grammar = String.raw`
  csv     = nl* record+
  record  = fields nl*
  fields  = field (',' field)*
  field   = escaped / txt
  escaped = esc+
  esc     = ["] [^"]* ["]
  txt     = [^,"\n\r]*
  nl      = \n / \r\n?
`;

const CSV = grit(CSV_grammar);

var input = `
a,b,c
d,"e,""f",g
`;

var output = CSV.parse(input);

write(output);
</textarea>
  <script>sandbox.RUN(9)</script><br>

<p>The parse tree is getting hard to read, but it is a simple data structure that an application program can process without much difficulty. The parse tree can be simplified and formatted for easier reading if necessary, but the firt priority should be to ensure that the grammar rules recognize the desired syntax and match the input text correctly.</p>
<p>The next example illustrates how the parse tree can be transformed into a simpler data structure to represent a table as a simple array of rows:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(10)' >Example 10</button>
    <button onClick='sandbox.RUN(10)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-10' style="width:49%" rows=17>const csv = grit`
    table = row+
    row   = nl* cell (',' cell)+
    cell  = [^,\n\r]*
    nl    = \n / \r\n?
`;

var parse_tree = csv.parse("a1,a2,a3\na2,b2,c2")

const tree_array = (tree) => 
    tree.map(([_, cell, cells]) =>
      [cell, ...cells.map(([_, x]) => x)]);

var arr = tree_array(parse_tree);

write(arr)
</textarea>
  <textarea id='sandbox-dst-10' style="width:49%" rows=17></textarea>
  
      <textarea id='sandbox-eg-10-0' hidden>const csv = grit`
    table = row+
    row   = nl* cell (',' cell)+
    cell  = [^,\n\r]*
    nl    = \n / \r\n?
`;

var parse_tree = csv.parse("a1,a2,a3\na2,b2,c2")

const tree_array = (tree) => 
    tree.map(([_, cell, cells]) =>
      [cell, ...cells.map(([_, x]) => x)]);

var arr = tree_array(parse_tree);

write(arr)
</textarea>
  <script>sandbox.RUN(10)</script><br>

<h2><span id="sect-Grammar Rule Logic"></span>Grammar Rule Logic</h2>
<p>We have seen how the PEG logic in the grammar rules can match a sequence of components, or a make a choice between different alternative components, and components may have a repeat quantifier suffix. It is very similar to the way a regex works, aside from the white-space (that is otherwise insignificant) used to separate components in a grammar rule.</p>
<p>However, the grammar rule operators are not exactly the same as the regex operators. Users do need to be aware that PEG logic is not the same as regex logic. A grammar rule can contain a hybrid mix of the two, but regex logic only applies inside a regex component, outside that its all PEG logic.</p>
<p>The PEG <code>/</code> choice operator is simpler than a regular expression <code>|</code> choice operator, it will match the first choice it can, and it will only try to match the next choice if the preceeding choice has failed. There is no back-tracking to try again later</p>
<p>The repeat operators: *, +, ? are also simpler than the regex operators since they can only match in one way, giving the maximum length match.</p>
<p>A simple regex component with a repeat suffix can not be logically distinguished from a PEG repeat operator (since there is no backtracking to let the regex try again). It is best to keep regex components simple, but a more complex regex component can be used, and they may employ regex logic internally. A regex component returns a string match result.</p>
<p>The lack of backtracking in the PEG logic can make it quite different from a regex. For example, here is a sequence of two regex components in a grammar rule that will fail to match an input that the same two components could match, if they were combined into a single regex:</p>
<pre class='demo-eg'>    [ab]+ [bc]+  -- fails on: "abb" (the [bc]+ finds nothing left to match).

    [ab]+[bc]+ -- will math: "abb" (after backtracking the [bc]+ will match the last b).
</pre>
<p>In this next PEG rule the second choice will never match anything:</p>
<pre class='demo-eg'>    x y* / x z*  -- only the first choice will ever match.

    xy*|xz* -- as a regex the xz* may match some input (after backtracking).
</pre>
<p>A PEG choice is deterministic, if the first choice matches then the second choice will not be tried. The regex is nondeterministic, it can try both choices to find any possible match. The PEG determinism is exactly what we want in order to recognise unambiguous computer languages (as against ambiguous natural languages).</p>
<p>Despite the fact that the grammar rule operators are simpler than their regular expression counterparts they can be used to match anything that a regular expression can match.</p>
<p>The grammar rules can go beyond a regular rexpression since they can call each other recusively. This gives them the added power to parse a nested syntax. In fact the PEG rules can be used to match the syntax for any context free language (i.e. the kind of syntax most computer programming languages are based on).</p>
<h2><span id="sect-Parse Trees"></span>Parse Trees</h2>
<p>A grammar-parser makes grammar rules a practical tool that can be used to simplify the use of bare regular expressions in every day programming. But the grammar rules can be used for far more than regular expression matching.</p>
<p>To illustrate that, here is a grammar for arithmetic expressions:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-11" onchange="sandbox.SELECT(11)">
      
      <option value='1'>Example 11.1</option>
      <option value='2'>Example 11.2</option>
      </select>
    <button onClick='sandbox.RUN(11)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-11' style="width:49%" rows=12>const arith = grit`
  expr   = factor ([+-] factor)*
  factor = term ([*/] term)*
  term   = \d+ / "(" expr ")"
`;

var e = arith.parse("1+2*3");

write(e);</textarea>
  <textarea id='sandbox-dst-11' style="width:49%" rows=12></textarea>
  
      <textarea id='sandbox-eg-11-0' hidden>const arith = grit`
  expr   = factor ([+-] factor)*
  factor = term ([*/] term)*
  term   = \d+ / "(" expr ")"
`;

var e = arith.parse("1+2*3");

write(e);</textarea>
      <textarea id='sandbox-eg-11-1' hidden>const expr = String.raw`
  expr   = factor ([+-] factor)*
  factor = term ([*/] term)*
  term   = \d+ / "(" expr ")"
`;

const arith = grit(expr);

var e = arith.parse("1+2*3");

write(e);
</textarea>
  <script>sandbox.RUN(11)</script><br>

<p>This is a sort of &ldquo;Hello World&rdquo; example for grammar parsers, but it goes beyond most programmer&rsquo;s normal use of regular expressions (it is not possible with a regular expression alone). Regular expressions can not generally be used to match nested structures.</p>
<p>Grammar theory often focuses on the structure of the parse tree. In this case the objective is to parse: <code>1+2*3</code> as <code>1+(2*3)</code> rather than: <code>(1+2)*3</code>.</p>
<pre><code class="language-box">       +                           *
      / \                         / \
    1    *      rather than      +   3
        / \                     / \
      2    3                   1   2
</code></pre>
<p>The parse tree generated by our grammar is correct, because multiplied <code>terms</code> will be associated before added <code>factors</code>. But the resulting data structure is not an elegant text-book tree! It is matching: <code>1+2*3</code> more like this: <code>(1,+,(2,(*,3)))</code>.</p>
<p>However, our focus here is on simple pragmatic grammar rules to recognize the input text, without too much regard for the detailed structure of the resulting parse tree.</p>
<p>An application program can walk any grammar rule parse tree quite easily. Rather than try to re-write the grammar rules to produce a different parse tree structure our approach here is to keep the grammar rules as a simple as possible. The focus is on recognition of the input text. The parse tree structure can be simplified separatley.</p>
<p>In fact the grammar parser machinery is well suited to processing the results of each grammar rule on the fly. This allows the parse tree to be simplified, or even for application processing to be applied. This can be implemented with so called grammar attributes, or semantic actions.</p>
<h2><span id="sect-Semantic Actions"></span>Semantic Actions</h2>
<p>A grammar rule may be given an associated semantic action which is a function that is applied to the result of a successful rule match.</p>
<p>To demonstrate, we can add semantic actions to our arithmetic expression grammar to make it into a calculator that can evaluate numeric results. The semantic actions are written as a set of named functions in an <code>evaluate</code> object, which is passed into the <code>grit</code> function along with the grammar rules:</p>

  <div class="sandbox controls">
    
      <select id="sandbox-select-12" onchange="sandbox.SELECT(12)">
      
      <option value='1'>Example 12.1</option>
      <option value='2'>Example 12.2</option>
      </select>
    <button onClick='sandbox.RUN(12)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-12' style="width:49%" rows=22>const arith = grit`
  expr   = factor ([+-] factor)*
  factor = term ([*/] term)*
  term   = \d+ / "(" expr ")"
`;

arith.actions = {
  expr:   ([f, fs]) =>
            fs.reduce((y, [op, x]) =>
              op === "+"? y+x : y-x, f),   
  factor: ([t, ts]) =>
            ts.reduce((y, [op, x]) =>
              op === "*"? y*x : y/x, t),
  term:   (x) => Number(x) || x[1]
}

var e = arith.parse("1+2*(3+4)-5");

write(e);</textarea>
  <textarea id='sandbox-dst-12' style="width:49%" rows=22></textarea>
  
      <textarea id='sandbox-eg-12-0' hidden>const arith = grit`
  expr   = factor ([+-] factor)*
  factor = term ([*/] term)*
  term   = \d+ / "(" expr ")"
`;

arith.actions = {
  expr:   ([f, fs]) =>
            fs.reduce((y, [op, x]) =>
              op === "+"? y+x : y-x, f),   
  factor: ([t, ts]) =>
            ts.reduce((y, [op, x]) =>
              op === "*"? y*x : y/x, t),
  term:   (x) => Number(x) || x[1]
}

var e = arith.parse("1+2*(3+4)-5");

write(e);</textarea>
      <textarea id='sandbox-eg-12-1' hidden>const expr = String.raw`
  expr   = factor ([+-] factor)*
  factor = term ([*/] term)*
  term   = \d+ / "(" expr ")"
`;

const evaluate = {
  expr:   ([f, fs]) =>
            fs.reduce((y, [op, x]) =>
              op === "+"? y+x : y-x, f),   
  factor: ([t, ts]) =>
            ts.reduce((y, [op, x]) =>
              op === "*"? y*x : y/x, t),
  term:   (x) => Number(x) || x[1]
}

const arith = grit(expr, evaluate);

var e = arith.parse("1+2*(3+4)-5");

write(e);
</textarea>
  <script>sandbox.RUN(12)</script><br>

<p>In this case there is a semantic action for each rule, using the same name as the rule. In general any action name can be used, with the function name appended to the rule after a <code>:</code> colon, and not all rules may need an action.</p>
<p>In this example it is very convenient to employ the JavaScript arrow <code>=&gt;</code> syntax for lambda functions, together with array pattern matching and a list <code>reduce</code> function. These features may not be familiar to all JavaScript programmers, but they will be familiar to functional programmers (there is nothing strange or pecuilar going on here).</p>
<p>The power and simplicity of using grammar rules with regular expression components and semantic actions should be clear.</p>
<h1><span id="sect-Conclusion"></span>Conclusion</h1>
<p>Regular expressions are a well established feature used in many modern programming languages. Regular expression execution engines are extremely fast. Unfortunately the regular expressions syntax is very cryptic and hard to read.</p>
<p>In practice regular expressions often need to be composed out of component parts. This is usually done with add-hoc program code. Instead of that, we are advocating the use of grammar rules to compose regular expression components in a neat standard format.</p>
<p>Grammar rules provide a great way to knit together regular expression components. They can be used to define almost any data format or domain specific language. Any unambiguous context free grammar.</p>
<p>The addition of semantic actions allows the parse tree to be be transformed into any data structure that best suits the application.</p>
<p>Semantic actions also provide an escape hatch to handle any odd irregular features in the grammar. With semantic actions the grammar is Turing complete, it can be used to recognize any language.</p>
<p>The hope is that the use of a grammar parser will become a standard tool for every day programming that can be used as easily as bare regular expressions. The use of grammar specifications should also enable much larger scale parsing to become routine.</p>
<p>Grammar rules make extemely neat and expressive specifications, and a grammar-parser makes it practical to embed grammar rules directly into program code.</p>
<pre hidden>"   smart
'   smart
</pre>

</body>
</html>
