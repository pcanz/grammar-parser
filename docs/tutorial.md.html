<!DOCTYPE HTML>
<html>
<head>
<meta lang=en charset="UTF-8">
<script>if (window.moko) alert("!!! moko global name conflict....");
window.moko = {}
</script>

<script>
// Grammar Parser -- an evolution of Grit.

// See docs at: https://github.com/pcanz/grammar-parser

/*	The MIT License (MIT)
 *
 *	Copyright (c) 2015,2016,2017,2018,2019 Peter Cashin
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files(the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 *	furnished to do so, subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included
 *	in all copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 *	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

;(function() { // module name-space wrapper -- see the end of this file...

/* -- grammar-rule grammar ---------------------------------------

    grammar = rule+
    rule    = name "=" expr ws act?

    expr    = seq ("/" seq)*
    seq     = (ws [&!]? term [*+?]?)*
    term    = ref / quote / regex / group

    name    = ws \w+
    ref     = name !\s*=
    group   = "(" expr ")"

    quote   = '"' [^"]* '"' / "'" [^']* "'"
    regex   = &[[\\^] (chs / par / misc)+
    chs     = [\[] ([^\]\\]* ([\\][^])?)+ [\]]
    par     = [(] ([^()]* par?)* [)]
    misc    = [^[()\s]+

    act     = ":" lines
    lines   = line (\s* !\S+\s*= line)*
    line    = [^\n\r]* 
    ws      = \s*  
*/

// -- parser code for grit_rules --------------------------------------

// The parser is a byte-code style interpreter, but encodes
// instructions an array data structure with string values.

/* parser instruction codes:

    ["^", "regex"]      match regexp
    ["=", rule]         call rule by name.
    [",", a, b, c, ...] sequence of instruction codes, all to succeed.
    ["/", a, b, c, ...] altrnatives, first to succeed.
    ["+", x]            matches one or more x, or fails.
    ["*", x]            matches any number of x, none matches "".
    ["?", x]            optional match: x / ""
    ["&", x]            lookahead: "" if x matches, else fails.
    ["!", x]            negation: fails if x matches, else "".
 
    The parser compiles rule names to rule indexes on the fly, and also
    compiles regexp's on the fly (to keep the code simple, and portable).

    The parser code can be exported as JSON.
*/

const grit_code = [
    {   name: "grammar", // grammar = rule+
        code: ["+",["=","rule"]] },

    {   name: "rule", // rule = name "=" expr ws act?
        code: [",",["=","name"],["^","\\s*="],["=","expr"],
                        ["=", "ws"],["?",["=","act"]]] },

    {   name: "expr", // expr = seq ("/" seq)*
        code: [",",["=","seq"],["*",[",",["^","\\s*/"],["=","seq"]]]] },

    {   // seq = (ws [&!]? term [*+?]?)*
        name: "seq",
        code: ["*",[",",["=","ws"],["^","[&!]?"],["=","term"],["^","[*+?]?"]]] },

    {   name: "term", // term = ref / quote/ regex / group
        code: ["/",["=","ref"],["=","quote"],["=","regex"],["=","group"]] },

    {   name: "name", // name = ws \w+
        code: [",",["^","[\\s]*"],["^","[\\w]+"]] },

    {   name: "ref", // ref = name !\s*=
        code: [",",["=","name"],["!",["^","[\\s]*="]]] },

    {   name: "quote", // quote = '"' [^"]* '"' / "'" [^']* "'"
        code: ["^","\\s*((?:'[^']*'|\"[^\"]*\")[\\w]*)"] },

    {   name: "regex", // regex = &[[\\^] (chs / par / misc)+
        code: [",",["&",["^","[[\\\\^]"]],["+",["/",["=","chs"],["=","par"],["=","misc"]]]] },

    {   name: "chs", // [\[] ([^\]\\]* ([\\][^])?)+ [\]]
        code: ["^","[[](?:[^\\]\\\\]*(?:[\\\\][^])?)+[\\]]"] },

    {   name: "par", // par = [(] ([^()]* par?)* [)]
        code: [",",["^","[(]"],["*",[",",["^","[^()]*"],["?",["=","par"]]]],["^","[)]"]] },

    {   name: "misc", // [^[()\s]+
        code: ["^","[^[()\\s]+"] },

    {   name: "group", // group = "(" expr ")"
        code: [",",["^","\\s*\\("],["=","expr"],["^","\\s*\\)"]] },

    {   name: "act", // act = ":" lines
        code: [",",["^","\\s*:"],["^","[^\\n\\r]*"], // line = [^\n\r]*
                ["*",[",",["^","\\s*"],["!",["^","\\S+\\s*="]],
                          ["^","[^\\n\\r]*"]]]] },

    {   name: "ws", // ws = \s* 
        code: ["^","\\s*"] }
];

resolve_code(grit_code); // maps names to indexes & compiles regexes

// -- compile peg rules into parser instruction codes --------------------

const grit_actions = { // semantic actions for parse tree nodes...

    // grammar = rule+
    "grammar": (rs) => rs,

    // rule = name "=" expr ws act?
    "rule": ([name, _, code, ws, action]) => {
        return {name, code, action};
    },

    // expr = seq ("/" seq)*
    "expr": ([seq, alts]) => {
        if (alts.length === 0) {
            return seq;
        } else {
            var seqs = alts.map(([_, seq]) => seq)
            return ["/", seq, ...seqs];
        }
    },

    // seq = (ws [&!]? term [*+?]?)*
    "seq": (xs) => {
        var ts = xs.map(([ws, pred, term, rep]) => {
            if (rep) { term = [rep, term]; }
            if (pred) { term = [pred, term];}
            return term;
        })
        if (ts.length === 1) return ts[0];
        return [",", ...ts];
    },

    // term = ref / match / group
    "term": (x) => x,

    // name = ws \w+
    "name": ([_, name]) => name,

    // ref = name !\s*=
    "ref":  ([name, _]) => ["=", name, null],

    // group = "(" expr ")"
    "group": ([_, expr]) => expr,

    // quote = '"' [^"]* '"' / "'" [^']* "'"
    "quote": (str) => { // quote => regex: \s*("...")\s*
        if (str.length === 2) { // empty quotes..
            return (str[0] === "'")? ["^","\uFFFF?"] : ["^","\\s*(\uFFFF?)"];
        }
        qt = str.slice(1,-1);
        if (str[0] === "'") return ["^",esc_regex(qt)];
        return ["^","\\s*("+esc_regex(qt)+")\\s*"];
    },

    // regex   = &[[\\] (chs / par / misc)*
    "regex": ([_, rs]) => rs[0]==='^'? 
                ["^", rs.slice(1).join('')] : ["^", rs.join('')],

    // par = [(] ([^()]* par?)* [)]
    "par": ([lp, ps, rp]) => { // par? => p, will be already done..
        var xps = ps.map(([x, p]) => p? x+p : x);
        return lp + xps.join('') + rp; 
    },

    // act = ":" lines
    "act": ([_, line, lines]) => {
        return string([line, lines]);
    },

    // ws = \s*
    "ws": (s) => s

} // grit_actions

function esc_regex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function rules_map(code) {
    return code.reduce((rm, rule, idx) => {
        rm[rule.name] = idx; return rm; }, {});
}

function resolve_code(code) {
    var name_idx = rules_map(code);

    function resolve (op) {
        if (!Array.isArray(op)) return op;
        if (op[0] === "^") {
            op[2] = op[2] || new RegExp(op[1],"uy"); // unicode sticky flags
            return op;
        }
        if (op[0] === "=") {
            op[2] = name_idx[op[1]];
            if (!op[2] && op[2]!==0) {
                throw new Error("*** missing rule '"+op[1]+"' ... ")
            }
            return op;
        }
        return op.map((x) => resolve(x));
    }
    var coded = code.map((rule) => {
        return resolve(rule.code);
    });

    return code;
}


// -- built-in semantic actions ---------------------------------------------


const std_actions = {

    xfy: (result) => { // a (op b)* => [op,x,y]
        function xfy(x, ys) {
            if (ys.length === 0) return x;
            var [op, y] = ys[0];
            return [op, x, xfy(y, ys.slice(1))]
        }
        var [x, ys] = result;
        return xfy(x, ys);
    },
 
    yfx: (result) => { // a (op b)* => [op,y,x]
        var [a, bs] = result;
        return bs.reduce((y, [op, b]) => [op, y, b], a)
    },

    xfx: (result) => { // a (op b)* => [a,op,b,op,c,...]
        var [a, bs] = result;
        return bs.reduce((y, b) => y.concat(b), [a])
    },

    yfy: (result) => { // a (_ b)* => [a,b,c,...]
        var [a, bs] = result;
        return bs.reduce((y, [_, b]) => y.concat(b), [a]);
    },

    flatten: (xs) => flatten(xs),

    string: (xs) => string(xs),

    number: (xs) => number(xs),

    x: (result) => result,
    n: (result) => Number(result),
    _: (result) => ""

}

function flatten(xs) {
    return Array.isArray(xs)?
        xs.reduce((y,x) => y.concat(flatten(x)),[]) : xs;
}

function string(xs) {
    return Array.isArray(xs)? flatten(xs).join('') : xs;
}

function number(xs) {
    return Number(string(xs));
}

// -- parser -- string-code interpreter ------------------------------------

function parser (code, input, actions={}, options={}) {
    var pos = 0;
    var inRule = "start"; // current rule trace 
    var ruleStack = [];
    var maxPos = 0; // high water mark
    var maxRule= ""; // inRule at maxPos
    var runOps = 0;
    var maxOps = 10000; // run away recursion check

    if (!code) {
        return report("missing grammar rule code...");
    }

    var start_name = code[0].name;
    var start = ["=", start_name, 0];

    if (typeof input !== "string") {
        try {
            input = String.raw(input);
        } catch(err) {
            input = '';
            return report("input is not a string...");
        }
    }

    if (typeof actions === 'function') {
        actions = { "?": actions } // catch all
    }

    if (options.trace) console.log("trace", start_name)

    var result = run(start); // run the parser engine...

    if (result === null) {
        return report("failed");
    }
    if (pos < input.length && !input.slice(pos).match(/^\s+$/)) {
        if (options.replay) replay();
        return report("fell short");
    }
    return result;

    // -- code engine -------------------------------------------

    function run(op) {

        if (runOps += 1 > maxOps) {
            return report("run away recursion...");
        }

        switch (op[0]) {

        case '^': // ["^", src, regex]
            var regex = op[2]; 
            regex.lastIndex = pos; // using regex.y sticky flag
            var mx = regex.exec(input);
            var trace = options.trace;
            if (trace) {
                if (typeof trace !== "string" || trace === inRule) {
                    var span = pos;
                    span += mx? ".."+(pos+mx[0].length) : ""
                    var match = mx? "=>"+mx[0] : "!";
                    console.log(span,inRule,regex,match);
                }
            }
            if (!mx) return null;
            pos += mx[0].length;
            if (pos > maxPos) { 
                maxPos = pos; 
                maxRule = inRule;
            }
            // return mx[1]||mx[0]; // used to skip white-space prefix
            if (mx.length === 1) return mx[0];
            if (mx.length === 2) return mx[1];
            return mx.slice(1);

        case '=': // ["=", name, idx]
            var idx = op[2];
            var rule = code[idx];
            if (!rule) { // bad grammar ...
                return report("missing rule "+idx+": '"+op[1]+"' ...");
            }
            ruleStack.push(inRule)
            inRule = op[1];
            var start = pos;
            var result = run(rule.code);
            inRule = ruleStack.pop();
            if (result === null) {
                pos = start;
                return null;
            }
            var {name, action} = rule;
            var val = run_action(result, {name, action, pos, input, posit});
            if (val !== null) return val;
            pos = start; // fail
            return null;

        case ',': // [",", ..., seq, ... ]
            var start = pos;
            var res = [];
            var i = 1;
                while (i < op.length) {
                var temp = run(op[i]);
                if (temp === null) {
                    pos = start;
                    return null;
                }
                res.push(temp);
                i += 1;
            }
            return res;

        case '/': // ["/", ..., alt, ... ]
            var start = pos;
            var res = null; // fail if no alt
            var j = 1;
            while (j < op.length) {
                res = run(op[j]);
                if (res !== null && pos > start) {
                    return res;
                }
                pos = start;
                j += 1;
            }
            return res;

        case '*': // ["*", op]
        var start = pos;
        var temp = run(op[1]);
        if (temp === null) return [];
        var res = [temp];
        while (true) {
            start = pos;
            temp = run(op[1]);
            if (temp === null || pos === start) break;
            res.push(temp);
        }
        return res;

        case '+': // ["+", op]
            var start = pos;
            var temp = run(op[1]);
            if (temp === null) return null;
            var res = [temp];
            while (true) {
                start = pos;
                temp = run(op[1]);
                if (temp === null || pos === start) break;
                res.push(temp);
            }
            return res;

        case '?': // ["?", op]
            var res = run(op[1])
            if (res === null) return "";
            return res;

        case '!': // ["!", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res === null) return "";
            return null;

        case '&': // ["&", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res !== null) return "";
            return null;

        default: // should never happen...
		    throw new Error("*** Undefined parse code op: "+JSON.stringify(op));
        }
    } // run

    function report(msg) {
        var at = pos + (maxPos>pos? ".."+maxPos : "") + " of " + input.length;
        var pre = pos<16? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var show = pre + input.slice(pos,pos+40);
        show = show.replace(/[\x00-\x1f]/g,"¬")
        if (input.length > pos+40) show += "..."
        var cursor = "";
        for (var i=0; i < pre.length; i+=1) cursor += " ";
        cursor += "^";
        var max = maxPos-pos>40? 42 : maxPos;
        for (var i=pos+1; i < max; i+=1) cursor += " ";
        cursor += "^";
        var report = "*** grammar '"+start_name+"' parse "+msg+
                    " after: '"+maxRule+"' at: "+at+"\n"+
                        show+"\n"+cursor;
        if (!options || (!options.silent && !options.console)) {
            throw new Error(report);
        } else if (options.console && !options.silent) {
            console.log(report);
        } else { // silent reporting...
            options.report = report;
        }
        return null;
    }

    function replay() {
        try {
            parser(code, input, actions, {trace:true});
        } catch(err) {
            // console.log(err);
        }
    }

    function posit(n) {
        console.log("posit", pos, n);
        pos = n;
    }

    function run_action(result, parse) {
        var fn = null;
        var {name, action} = parse; // {name, action, pos, input, posit}
        if (action) {
            var ax = action.match(/^\s*(\S+)/);
            act = ax? ax[1] : "";
            fn = actions[act] || std_actions[act];
            if (!fn) { // synthetic action: _x_ etc..
                if (act.match(/^[_x]+$/) && Array.isArray(result)) {
                    var res = [];
                    result.forEach((x, i) => {
                        var k = act[i];
                        if (k === "x") res.push(x);
                    });
                    if (res.length === 1) return res[0];
                    return res;
                }            
            }
        } // action
        fn = fn || actions[name] || actions["?"];
        if (fn) {
            try {
                return fn(result, parse);
            } catch(err) {
                report("Bad action for '"+name+"':\n"+err);
            }
        }
        return result // [name, result] // default result..
    }


} // parser


// -- grammar_parser --------------------------------------------------------

function grammar_parser (grammar, actions) {

    let code = parser(grit_code, grammar, grit_actions)

    if (!code) return null;
    
    resolve_code(code);

    function parse(input, options) {
        return parser(code, input, this.actions, options);
    };

    function match(input, options) {
        try {
            var result = this.parse(input, options);
        } catch(err) {
            this.err = err;
            return null;
        }
        return result;
    }

    return {parse, match, grammar, actions, code};
}

// module.exports = grammar_parser;
// expose grammar_parser ----------------------------------------------

if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = grammar_parser;
} else if (typeof define === 'function' && define.amd) {
    define(function() { return grammar_parser; });
} else {
    this.grammar_parser = grammar_parser;
}

}).call(function() {
return this || (typeof window !== 'undefined' ? window : global);
}()); // outer funtion name-space wrapper

;
</script> 
<script type="text/javascript">
    var moko = window.moko || (window.moko = {});
    moko.sandbox = {};
    moko.sandbox.write = (txt) => res += JSON.stringify(txt)
    var sandbox = moko.sandbox
    sandbox.RESET = (i) => {
	    var src = sandbox.textarea_src(i)
        var example = sandbox.example(i, 0)
	    src.value = example.value
	    sandbox.RUN(i);
    }
    sandbox.RUN = (i) => {
        var src = sandbox.textarea_src(i)
        var dst = sandbox.textarea_dst(i)
        var res = "";
        try {
            var verbs = {
                // grit: window.Grit,
                grammar_parser: window.grammar_parser, // new grit,
                grit: window.grammar_parser, // grit 3.x
                write: (...args) => {
                    res += args.map((arg)=>
                        JSON.stringify(arg)).join(' ')+"\r\n\r\n";
                },
                print: (...args) => {
                    res += args.map((arg)=>
                        JSON.stringify(arg,null,2)).join(' ')+"\r\n\r\n";
                }    
            }
            var keys = Object.keys(verbs);
            var vals = keys.map((k)=> verbs[k])
            var fn = new Function(...keys, src.value)
            fn(...vals);
        } catch(err) {
            res = err
        }
        dst.value = res;
    }
    sandbox.SELECT = (i) => {
        var x = document.getElementById("sandbox-select-"+i).value;
        var example = sandbox.example(i, x-1)
        var src = sandbox.textarea_src(i)
        src.value = example.value
        sandbox.RUN(i);
    }
    sandbox.textarea_src = (i) => document.getElementById('sandbox-src-'+i);
    sandbox.textarea_dst = (i) => document.getElementById('sandbox-dst-'+i);
    sandbox.example = (i, n) => document.getElementById('sandbox-eg-'+i+'-'+n);
</script>
<style>
textarea {font-family: monospace; font-size:10pt; background:whitesmoke;}
</style>

</head>
<body>
<h1><span id="sect-Grit Tutorial"></span>Grit Tutorial</h1>
<p>In english we say: &ldquo;Tom&rdquo;, or &ldquo;Tom and Dick&rdquo; or &ldquo;Tom, Dick and Harry&rdquo;. We do not say: &ldquo;Tom and Dick, Harry&rdquo;, or &ldquo;Tom, Dick&rdquo;. The grammar rules can be defined something like this:</p>
<ol>
<li>A name (e.g. &ldquo;Tom&rdquo;).</li>
<li>Or, a name, followed by &ldquo;and&rdquo;, then another name.</li>
<li>Or, a name, follwed by a comma name, followed by &ldquo;and&rdquo; and a last name.</li>
</ol>
<p>Using the <a href="https://github.com/pcanz/grammar-parser/"><code>grit-parser</code></a> we could try writing a grammar like this:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(1)' >Example 1</button>
    <button onClick='sandbox.RUN(1)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-1' style="width:49%" rows=9>const tdh = grit`
    tdh  = name 
         / name "and" name 
         / name "," name "and" name
    name = \w+
`;

write(tdh.parse("Tom, Dick & Harry"));
</textarea>
  <textarea id='sandbox-dst-1' style="width:49%" rows=9></textarea>
  
      <textarea id='sandbox-eg-1-0' hidden>const tdh = grit`
    tdh  = name 
         / name "and" name 
         / name "," name "and" name
    name = \w+
`;

write(tdh.parse("Tom, Dick & Harry"));
</textarea>
  <script>sandbox.RUN(1)</script><br>

<p>Woops, that didn&rsquo;t work! Let&rsquo;s see what is happening here.</p>
<p>We have defined two grammar rules (<code>tdh</code> and <code>name</code>). The rules start on a new line with their name, and white-space in a rule is insignificant except for separating components.</p>
<p>The <code>tdh</code> rule has three options separated by the <code>/</code> choice operator.</p>
<p>The <code>name</code> rule is defined with a regular expression (as usual <code>\w+</code> is one or more word character).</p>
<p>The <code>grit</code> function is a JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template literal tag function</a> which reads the Grit grammar rules and generates a <code>tdh</code> parser object. The parser provides a <code>parse</code> function that will match input text according to the grammar rule specification.</p>
<p>This grammar fails because the first option (a name) matches, and the choice is satisfied, so the parse ends. The other options are not checked, the choice always settles for the first option that matches.</p>
<p>So we have to write it like this:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(2)' >Example 2</button>
    <button onClick='sandbox.RUN(2)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-2' style="width:49%" rows=9>const tdh = grit`
    tdh  = name "," name "and" name
         / name "and" name
         / name 
    name = \w+
`;

write(tdh.parse("Tom, Dick and Harry"));
</textarea>
  <textarea id='sandbox-dst-2' style="width:49%" rows=9></textarea>
  
      <textarea id='sandbox-eg-2-0' hidden>const tdh = grit`
    tdh  = name "," name "and" name
         / name "and" name
         / name 
    name = \w+
`;

write(tdh.parse("Tom, Dick and Harry"));
</textarea>
  <script>sandbox.RUN(2)</script><br>

<p>That&rsquo;s what we wanted to see!</p>
<p>The <code>tdh</code> rule first matches its five components, the <code>name</code> components, and the literal <code>&quot;,&quot;</code> and <code>&quot;and&quot;</code> components.</p>
<p>The second option (after the <code>/</code> choice operator) will only be tried if the first option fails (and there is no back-tracking).</p>
<p>You can edit the example. If you delete the &ldquo;Dick&rdquo; and &ldquo;Harry&rdquo; you can see that the shorter options also work. After editing, hit the RUN button to parse the new input. If you hit the Example button the original will be restored.</p>
<h2><span id="sect-Grit Rules"></span>Grit Rules</h2>
<p>That works, but we can do better. Notice that the first name may need to be matched more than once, which is verbose and inefficient (although a clever compiler could arrange to cache the name).</p>
<p>In Grit it is idiomatic to write it more succinctly as:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(3)' >Example 3</button>
    <button onClick='sandbox.RUN(3)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-3' style="width:49%" rows=7>const tdh = grit`
    tdh  = name (("," name)? "and" name)?
    name = \w+
`;

write(tdh.parse("Tom, Dick and Harry"));
</textarea>
  <textarea id='sandbox-dst-3' style="width:49%" rows=7></textarea>
  
      <textarea id='sandbox-eg-3-0' hidden>const tdh = grit`
    tdh  = name (("," name)? "and" name)?
    name = \w+
`;

write(tdh.parse("Tom, Dick and Harry"));
</textarea>
  <script>sandbox.RUN(3)</script><br>

<p>Notice that the result is a nested list structure, we call it a parse tree.</p>
<p>The <code>?</code> suffix operator is the same as in a regular expression, it says that the &ldquo;and&rdquo; part is optional, as is the comma part.</p>
<p>But notice that because of the nested structure there is no way to match a comma name unless it is followed by an &ldquo;and&rdquo; name.</p>
<p>We can embellish this a little more by allowing &ldquo;&amp;&rdquo; in place of &ldquo;and&rdquo; and by allowing a list of comma separated names:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(4)' >Example 4</button>
    <button onClick='sandbox.RUN(4)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-4' style="width:49%" rows=8>const tdh = grit`
    tdh  = name (("," name)* and name)?
    and  = "and" / "&"
    name = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <textarea id='sandbox-dst-4' style="width:49%" rows=8></textarea>
  
      <textarea id='sandbox-eg-4-0' hidden>const tdh = grit`
    tdh  = name (("," name)* and name)?
    and  = "and" / "&"
    name = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <script>sandbox.RUN(4)</script><br>

<p>The expression <code>(&quot;,&quot; name)*</code> can match zero or more times, so it generates a list.</p>
<p>The <code>*</code> repeat allows any number of matches, and if there are none then the result will be an empty list <code>[]</code>. Edit it to see.</p>
<p>The <code>+</code> repeat works the same way for one or more matches.</p>
<p>Both repeat operators will match as many times as possible (longest match), and they will not back-off to any shorter matches.</p>
<p>However, the &ldquo;?&rdquo; means optional, if it fails it returns <code>&quot;&quot;</code> an empty match string (it matched nothing). This is not quite the same as a list of zero or one match. If you edit the input to just: &ldquo;Tom&rdquo;, then you will see the result.</p>
<h2><span id="sect-White-space"></span>White-space</h2>
<p>You may not have noticed but the rules do not mention white-space at all, so how did they match the white-space in the input?</p>
<p>The answer is the literal in double quotes (<code>&quot;,&quot;</code> and <code>&quot;and&quot;</code>). These literals will match any leading and trailing white space. This is a convenience feature, using a literal with single quotes will not match any extra white space.</p>
<p>We could match white-space explicitly, for eample if we want to insist that there must be no space before the comma, only after it:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(5)' >Example 5</button>
    <button onClick='sandbox.RUN(5)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-5' style="width:49%" rows=9>const tdh = grit`
    tdh   = name ((comma name)* and name)?
    and   = "and" / "&"
    comma = ',' \s*
    name  = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <textarea id='sandbox-dst-5' style="width:49%" rows=9></textarea>
  
      <textarea id='sandbox-eg-5-0' hidden>const tdh = grit`
    tdh   = name ((comma name)* and name)?
    and   = "and" / "&"
    comma = ',' \s*
    name  = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <script>sandbox.RUN(5)</script><br>

<p>Try adding a space before the comma and it will fail, but the previous examples will still match.</p>
<p>The <code>comma</code> rule now returns a list of two components (the comma and white-space). We can simplify that by putting the two components together into a single regular expression component:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(6)' >Example 6</button>
    <button onClick='sandbox.RUN(6)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-6' style="width:49%" rows=9>const tdh = grit`
    tdh   = name ((comma name)* and name)?
    and   = "and" / "&"
    comma = [,]\s*
    name  = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <textarea id='sandbox-dst-6' style="width:49%" rows=9></textarea>
  
      <textarea id='sandbox-eg-6-0' hidden>const tdh = grit`
    tdh   = name ((comma name)* and name)?
    and   = "and" / "&"
    comma = [,]\s*
    name  = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <script>sandbox.RUN(6)</script><br>

<p>The comma rule now only has one component, it is now a single regular expression that matches a comma followed by any number of white-space characters.</p>
<h2><span id="sect-Regular Expression Components"></span>Regular Expression Components</h2>
<p>In general a regular expression component can be complex. Any length without white-space (except inside square brackets). However a regular expression must start with a: <code>[</code>, <code>\</code>, or <code>^</code> character.</p>
<p>A <code>^</code> prefix means the regular expression will match immediately, but in a grammar rule every component will do that anyway, without the need for an explicit <code>^</code> prefix.</p>
<p>A regular expression may contain parenthesis for capture groups as usual, so the <code>comma</code> rule can capture the comma alone, without the following white-space. But the regular expression can&rsquo;t start with an open parenthesis, so this is a case where a prefix <code>^</code> is required:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(7)' >Example 7</button>
    <button onClick='sandbox.RUN(7)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-7' style="width:49%" rows=9>const tdh = grit`
    tdh   = name ((comma name)* and name)?
    and   = "and" / "&"
    comma = ^([,])\s*
    name  = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <textarea id='sandbox-dst-7' style="width:49%" rows=9></textarea>
  
      <textarea id='sandbox-eg-7-0' hidden>const tdh = grit`
    tdh   = name ((comma name)* and name)?
    and   = "and" / "&"
    comma = ^([,])\s*
    name  = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <script>sandbox.RUN(7)</script><br>

<p>It is usually best to keep regular expressions short and simple. Capture groups are not usually needed since every separate component will appear as a match result.</p>
<h2><span id="sect-Grammar Operators"></span>Grammar Operators</h2>
<p>In English there is an <a href="https://www.grammarly.com/blog/what-is-the-oxford-comma-and-why-do-people-care-so-much-about-it/">&ldquo;Oxford comma&rdquo;</a>, an extra comma at the end of a list, just before the final &ldquo;and&rdquo;. We might try to add this option to our grammar like this:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(8)' >Example 8</button>
    <button onClick='sandbox.RUN(8)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-8' style="width:49%" rows=10>const tdh = grit`
    tdh   = name (list? and name)?
    list  = (comma name)+ comma?
    and   = "and" / "&"
    comma = ',' \s*
    name  = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <textarea id='sandbox-dst-8' style="width:49%" rows=10></textarea>
  
      <textarea id='sandbox-eg-8-0' hidden>const tdh = grit`
    tdh   = name (list? and name)?
    list  = (comma name)+ comma?
    and   = "and" / "&"
    comma = ',' \s*
    name  = \w+
`;

write(tdh.parse("Tom, Dick, Sam and Harry"));
</textarea>
  <script>sandbox.RUN(8)</script><br>

<p>Good try, but this does not work!</p>
<p>If you add an Oxford comma after &ldquo;Sam&rdquo; you will see why (hint: the &ldquo;and&rdquo; can be matched as a <code>name</code>).</p>
<p>The <code>+</code> operator will match as many comma names as possible, and it will not back off to match anything shorter. This is not the same as a <code>+</code> in a regular expression, in a regular expression the <code>+</code> repeat can back-off to a shorter match if necessary.</p>
<p>The Grit grammar rules use <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG</a> (Parser Expression Grammar) logic, which is simpler than regular expression logic.</p>
<p>Let&rsquo;s fix the Oxford comma. A simple patch to the <code>name</code> rule would work:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(9)' >Example 9</button>
    <button onClick='sandbox.RUN(9)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-9' style="width:49%" rows=10>const tdh = grit`
    tdh   = name (list? and name)?
    list  = (comma name)+ comma?
    and   = "and" / "&"
    comma = ',' \s*
    name  = !and \w+
`;

write(tdh.parse("Tom, Dick, Sam, and Harry"));
</textarea>
  <textarea id='sandbox-dst-9' style="width:49%" rows=10></textarea>
  
      <textarea id='sandbox-eg-9-0' hidden>const tdh = grit`
    tdh   = name (list? and name)?
    list  = (comma name)+ comma?
    and   = "and" / "&"
    comma = ',' \s*
    name  = !and \w+
`;

write(tdh.parse("Tom, Dick, Sam, and Harry"));
</textarea>
  <script>sandbox.RUN(9)</script><br>

<p>The <code>!</code> prefix operator will check that there is <em>not</em> a match. It will fail if there is a match, and a match will return an empty string without consuming any input.</p>
<p>The <code>!</code> oerator is used here in the <code>name</code> rule to exclude the &ldquo;and&rdquo; word from matching as a name.</p>
<p>A <code>&amp;</code> prefix operator is also available, it will check there <em>is</em> a match. It fails if the match fails, or it suceeds and matches nothing.</p>
<p>This <code>name</code> rule works, but it&rsquo;s a kludge. The problem is that there is no clear way to diferentiate between a name and the &ldquo;and&rdquo; word. This is a commmon source of trouble in the very foundations of the syntax.</p>
<p>In this example the names are proper names that start with a captial letter. This allows us to separate the names from an &ldquo;and&rdquo; word (and any other prose):</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(10)' >Example 10</button>
    <button onClick='sandbox.RUN(10)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-10' style="width:49%" rows=10>const tdh = grit`
    tdh   = name (list? and name)?
    list  = (comma name)+ comma?
    and   = "and" / "&"
    comma = ',' \s*
    name  = [A-Z][a-z]*
`;

write(tdh.parse("Tom, Dick, Sam, and Harry"));
</textarea>
  <textarea id='sandbox-dst-10' style="width:49%" rows=10></textarea>
  
      <textarea id='sandbox-eg-10-0' hidden>const tdh = grit`
    tdh   = name (list? and name)?
    list  = (comma name)+ comma?
    and   = "and" / "&"
    comma = ',' \s*
    name  = [A-Z][a-z]*
`;

write(tdh.parse("Tom, Dick, Sam, and Harry"));
</textarea>
  <script>sandbox.RUN(10)</script><br>

<p>The <code>name</code> rule defines proper names using a regular expression which will match a capital letter followed by any number or lower-case letters.</p>
<h2><span id="sect-Action Functions"></span>Action Functions</h2>
<p>Now that our grammar is doing what we want it is time to clean up the messy parse tree structure that the parser generates.</p>
<p>This is a job for semantic action functions:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(11)' >Example 11</button>
    <button onClick='sandbox.RUN(11)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-11' style="width:49%" rows=19>const tdh = grit`
    tdh   = name (list? and name)?
    list  = (comma name)+ comma?
    and   = "and" / "&"
    comma = ',' \s*
    name  = [A-Z][a-z]*
`;
tdh.actions = {
    tdh: ([name, more]) => {
        if (more === "") return name;
        var [list, and, last] = more;
        return [name, ...list, last];
    },
    list: ([xs, _]) => 
        xs.map(([_,name]) => name)
}

write(tdh.parse("Tom, Dick, Sam, and Harry"));
</textarea>
  <textarea id='sandbox-dst-11' style="width:49%" rows=19></textarea>
  
      <textarea id='sandbox-eg-11-0' hidden>const tdh = grit`
    tdh   = name (list? and name)?
    list  = (comma name)+ comma?
    and   = "and" / "&"
    comma = ',' \s*
    name  = [A-Z][a-z]*
`;
tdh.actions = {
    tdh: ([name, more]) => {
        if (more === "") return name;
        var [list, and, last] = more;
        return [name, ...list, last];
    },
    list: ([xs, _]) => 
        xs.map(([_,name]) => name)
}

write(tdh.parse("Tom, Dick, Sam, and Harry"));
</textarea>
  <script>sandbox.RUN(11)</script><br>

<p>The <code>tdh</code> and <code>list</code> action functions remove the syntax &ldquo;noise&rdquo; to transform the result into a clean AST (Abstract Syntax Tree).</p>
<p>The grammar rules specify a parser that will match the input without any action functions. You can delete all the action functions in the last example to see this (it&rsquo;s the same as the previous example).</p>
<h2><span id="sect-Lexer"></span>Lexer</h2>
<p>Now for a digression to compare our Grit grammar with a more traditonal parser design.</p>
<p>The traditional way to build a parser is to first transform the input text into a list of <em>tokens</em> eliminating the white-space and comments. This is called a <em>lexer</em>.</p>
<p>The parser then takes a list of tokens as input and applies the grammar rules to generate an AST.</p>
<p>Here is a little lexer for our example:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(12)' >Example 12</button>
    <button onClick='sandbox.RUN(12)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-12' style="width:49%" rows=16>const lex = grit`
    tokens = (token ws)*
    token  = name / syntax
    name   = [A-Z][a-z]*
    syntax = ',' / and
    and    = 'and' / '&'
    ws     = \s*
`;
lex.actions = {
    tokens: (ts) => ts.map(([t,_])=>t),
    and: () => '&'
};

var input = "Tom, Dick, Sam, and Harry";
write(lex.parse(input));
</textarea>
  <textarea id='sandbox-dst-12' style="width:49%" rows=16></textarea>
  
      <textarea id='sandbox-eg-12-0' hidden>const lex = grit`
    tokens = (token ws)*
    token  = name / syntax
    name   = [A-Z][a-z]*
    syntax = ',' / and
    and    = 'and' / '&'
    ws     = \s*
`;
lex.actions = {
    tokens: (ts) => ts.map(([t,_])=>t),
    and: () => '&'
};

var input = "Tom, Dick, Sam, and Harry";
write(lex.parse(input));
</textarea>
  <script>sandbox.RUN(12)</script><br>

<p>The result is a nice clean list of tokens, that&rsquo;s what a lexer does.</p>
<p>A traditional parser takes a list of tokens as input and the grammar is defined in terms of tokens. But the Grit grammar works on text strings, and it integrates the lexer function into the grammar rules. In practice this is a much neater approach.</p>
<p>But let&rsquo;s forge ahead with the traditional separate lexer and parser to see what that looks like:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(13)' >Example 13</button>
    <button onClick='sandbox.RUN(13)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-13' style="width:49%" rows=34>const tdh = grit`
    tdh   = name (list last)?
    list  = (comma name)*
    last  = comma? '&' name
    name  = \w+
    comma = ','
`;
tdh.actions = {
    tdh: ([name,[list, last]]) => last?
        [name, ...list, last] : name,
    list: (xs) => xs.map(([_,n]) => n),
    last: ([_, and, name]) => name
}

const lex = grit`
    tokens = (token ws)*
    token  = name / syntax
    name   = [A-Z][a-z]*
    syntax = ',' / and
    and    = 'and' / '&'
    ws     = \s*
`;
lex.actions = {
    tokens: (ts) => ts.map(([t,_])=>t),
    and: () => '&'
};

var input = "Tom, Dick, Sam, and Harry";

var tokens = lex.parse(input);
var parse = tdh.parse(tokens.join(''));

write(parse);
</textarea>
  <textarea id='sandbox-dst-13' style="width:49%" rows=34></textarea>
  
      <textarea id='sandbox-eg-13-0' hidden>const tdh = grit`
    tdh   = name (list last)?
    list  = (comma name)*
    last  = comma? '&' name
    name  = \w+
    comma = ','
`;
tdh.actions = {
    tdh: ([name,[list, last]]) => last?
        [name, ...list, last] : name,
    list: (xs) => xs.map(([_,n]) => n),
    last: ([_, and, name]) => name
}

const lex = grit`
    tokens = (token ws)*
    token  = name / syntax
    name   = [A-Z][a-z]*
    syntax = ',' / and
    and    = 'and' / '&'
    ws     = \s*
`;
lex.actions = {
    tokens: (ts) => ts.map(([t,_])=>t),
    and: () => '&'
};

var input = "Tom, Dick, Sam, and Harry";

var tokens = lex.parse(input);
var parse = tdh.parse(tokens.join(''));

write(parse);
</textarea>
  <script>sandbox.RUN(13)</script><br>

<p>Integrating the lexer and parser back together again:</p>

  <div class="sandbox controls">
    
      <button onClick='sandbox.RESET(14)' >Example 14</button>
    <button onClick='sandbox.RUN(14)'
            style="vertical-align:top">RUN</button>
  </div>
  <textarea id='sandbox-src-14' style="width:49%" rows=21>const tdh = grit`
    tdh   = name (list last)?
    list  = ("," name)*
    last  = ","? and name
    name  = [A-Z][a-z]*
    and   = "and" / "&"
`;
tdh.actions = {
    tdh: ([name,[list, last]]) => last?
        [name, ...list, last] : name,
    list: (xs) => xs.map(([_,n]) => n),
    last: ([_, and, name]) => name,
    and: () => '&'
}

var input = "Tom, Dick, Sam, and Harry";

var parse = tdh.parse(input);

write(parse);
</textarea>
  <textarea id='sandbox-dst-14' style="width:49%" rows=21></textarea>
  
      <textarea id='sandbox-eg-14-0' hidden>const tdh = grit`
    tdh   = name (list last)?
    list  = ("," name)*
    last  = ","? and name
    name  = [A-Z][a-z]*
    and   = "and" / "&"
`;
tdh.actions = {
    tdh: ([name,[list, last]]) => last?
        [name, ...list, last] : name,
    list: (xs) => xs.map(([_,n]) => n),
    last: ([_, and, name]) => name,
    and: () => '&'
}

var input = "Tom, Dick, Sam, and Harry";

var parse = tdh.parse(input);

write(parse);
</textarea>
  <script>sandbox.RUN(14)</script><br>

<p>A lexer is not needed, but it helps to think about the semantic tokens, and to separate them out from the tokens for syntax and white-space.</p>
<p>The end result is very similar to our previous version.</p>
<h2><span id="sect-Summary"></span>Summary</h2>
<p>We have used a very simple example and beaten it to death to illustrate most of the Grit grammar features:</p>
<ul>
<li>We have touched on all the grammar operators: <code>/ * + ? ! &amp;</code></li>
<li>Seen how regular expression components can be used.</li>
<li>Used action functions to generate a clean AST.</li>
</ul>
<p>If you have managed to read through all the examples then well done! You should be able to start writing your own grammars now. If you are unsure then try editing the examples here to play around a bit more.</p>
<p>For further reading see the <a href="https://pcanz.github.io/grammar-parser/">Grit grammar</a> documents.</p>
<pre hidden>"   smart
'   smart
</pre>
<style type="text/css">
	body {
		font-family: 'Helvetica Neue', Helvetica, Arial, serif;
		font-size: 1em;
		line-height: 1.5;
		color: #505050;
	}
	code.language-eg { display:block; background:whitesmoke; margin:0pt 10pt;}
</style>

</body>
</html>
