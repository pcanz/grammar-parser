<!DOCTYPE HTML>
<html>
<head>
<meta lang=en charset="UTF-8">
<style>
body {
    font-family: 'Helvetica Neue', Helvetica, Arial, serif;
    font-size: 1em; line-height: 1.5; color: #505050;
}
.code { background: whitesmoke; margin:0pt 10pt;}
blockquote {border-left: solid thick gainsboro; padding-left:5pt;}
h1,h2,h3,h4 {border-bottom: thin solid gainsboro; }
.key-val { margin:0px; }
.key-val-blk { margin:0px; margin-left:20pt; }
[data-tight='false'] > li {margin-bottom:12pt;}
q { quotes: "“" "”" "‘" "’"; }

</style>
<script>
// grit-parser loads itself into: window.grit_parser
// Grammar Parser -- an evolution of Grit.

// See docs at: https://github.com/pcanz/grammar-parser

/*	The MIT License (MIT)
 *
 *	Copyright (c) 2015,2016,2017,2018,2019 Peter Cashin
 *
 *	Permission is hereby granted, free of charge, to any person obtaining a copy
 *	of this software and associated documentation files(the "Software"), to deal
 *	in the Software without restriction, including without limitation the rights
 *	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *	copies of the Software, and to permit persons to whom the Software is
 *	furnished to do so, subject to the following conditions:
 *
 *	The above copyright notice and this permission notice shall be included
 *	in all copies or substantial portions of the Software.
 *
 *	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 *	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *  DEALINGS IN THE SOFTWARE.
 */

;(function() { // module name-space wrapper -- see the end of this file...

/* -- grammar-rule grammar ---------------------------------------

    grammar = rule+
    rule    = name "=" expr ws act?

    expr    = seq ("/" seq)*
    seq     = (ws [&!]? term [*+?]?)*
    term    = ref / quote / regex / group

    name    = ws \w+
    ref     = name !\s*=
    group   = "(" expr ")"

    quote   = '"' [^"]* '"' / "'" [^']* "'"
    regex   = &[[\\^] (chs / par / misc)+
    chs     = [\[] ([^\]\\]* ([\\][^])?)+ [\]]
    par     = [(] ([^()]* par?)* [)]
    misc    = [^[()\s]+

    act     = ":" lines
    lines   = line (\s* !\S+\s*= line)*
    line    = [^\n\r]* 
    ws      = \s*  
*/

// -- parser code for grit_rules --------------------------------------

// The parser is a byte-code style interpreter, but encodes
// instructions an array data structure with string values.

/* parser instruction codes:

    ["^", "regex"]      match regexp
    ["=", rule]         call rule by name.
    [",", a, b, c, ...] sequence of instruction codes, all to succeed.
    ["/", a, b, c, ...] alternatives, first to succeed.
    ["+", x]            matches one or more x, or fails.
    ["*", x]            matches any number of x, none matches "".
    ["?", x]            optional match: x / ""
    ["&", x]            lookahead: "" if x matches, else fails.
    ["!", x]            negation: fails if x matches, else "".
    
    The parser compiles rule names to rule indexes on the fly, and also
    compiles regexp's on the fly (to keep the code simple, and portable).

    The parser code can be exported as JSON.
*/

const grit_code = [
    {   name: "__grit__grammar", // grammar = rule+
        code: ["+",["=","rule"]] },

    {   name: "rule", // rule = name "=" expr ws act?
        code: [",",["=","name"],["^","\\s*="],["=","expr"],
                        ["=", "ws"],["?",["=","act"]]] },

    {   name: "expr", // expr = seq ("/" seq)*
        code: [",",["=","seq"],["*",[",",["^","\\s*/"],["=","seq"]]]] },

    {   // seq = (ws [&!]? term [*+?]?)*
        name: "seq",
        code: ["*",[",",["=","ws"],["^","[&!]?"],["=","term"],["^","[*+?]?"]]] },

    {   name: "term", // term = ref / quote/ regex / group
        code: ["/",["=","ref"],["=","quote"],["=","regex"],["=","group"]] },

    {   name: "name", // name = ws \w+
        code: [",",["^","[\\s]*"],["^","[\\w]+"]] },

    {   name: "ref", // ref = name !\s*=
        code: [",",["=","name"],["!",["^","[\\s]*="]]] },

    {   name: "quote", // quote = '"' [^"]* '"' / "'" [^']* "'"
        code: ["^","\\s*((?:'[^']*'|\"[^\"]*\")[\\w]*)"] },

    {   name: "regex", // regex = &[[\\^] (chs / par / misc)+
        code: [",",["&",["^","[[\\\\^]"]],["+",["/",["=","chs"],["=","par"],["=","misc"]]]] },

    {   name: "chs", // [\[] ([^\]\\]* ([\\][^])?)+ [\]]
        code: ["^","[[](?:[^\\]\\\\]*(?:[\\\\][^])?)+[\\]]"] },

    {   name: "par", // par = [(] ([^()]* par?)* [)]
        code: [",",["^","[(]"],["*",[",",["^","[^()]*"],["?",["=","par"]]]],["^","[)]"]] },

    {   name: "misc", // [^[()\s]+
        code: ["^","[^[()\\s]+"] },

    {   name: "group", // group = "(" expr ")"
        code: [",",["^","\\s*\\("],["=","expr"],["^","\\s*\\)"]] },

    {   name: "act", // act = ":" lines
        code: [",",["^","\\s*:"],["^","[^\\n\\r]*"], // line = [^\n\r]*
                ["*",[",",["^","\\s*"],["!",["^","\\S+\\s*="]],
                            ["^","[^\\n\\r]*"]]]] },

    {   name: "ws", // ws = \s* 
        code: ["^","\\s*"] }
];

resolve_code(grit_code); // maps names to indexes & compiles regexes

// -- compile peg rules into parser instruction codes --------------------

const grit_actions = { // semantic actions for parse tree nodes...

    // grammar = rule+
    "grammar": (rs) => rs,

    // rule = name "=" expr ws act?
    "rule": ([name, _, code, ws, action]) => {
        return {name, code, action};
    },

    // expr = seq ("/" seq)*
    "expr": ([seq, alts]) => {
        if (alts.length === 0) {
            return seq;
        } else {
            var seqs = alts.map(([_, seq]) => seq)
            return ["/", seq, ...seqs];
        }
    },

    // seq = (ws [&!]? term [*+?]?)*
    "seq": (xs) => {
        var ts = xs.map(([ws, pred, term, rep]) => {
            if (rep) { term = [rep, term]; }
            if (pred) { term = [pred, term];}
            return term;
        })
        if (ts.length === 1) return ts[0];
        return [",", ...ts];
    },

    // term = ref / match / group
    "term": (x) => x,

    // name = ws \w+
    "name": ([_, name]) => name,

    // ref = name !\s*=
    "ref":  ([name, _]) => ["=", name, null],

    // group = "(" expr ")"
    "group": ([_, expr]) => expr,

    // quote = '"' [^"]* '"' / "'" [^']* "'"
    "quote": (str) => { // quote => regex: \s*("...")\s*
        if (str.length === 2) { // empty quotes..
            return (str[0] === "'")? ["^","\uFFFF?"] : ["^","\\s*(\uFFFF?)"];
        }
        qt = str.slice(1,-1);
        if (str[0] === "'") return ["^",esc_regex(qt)];
        return ["^","\\s*("+esc_regex(qt)+")\\s*"];
    },

    // // regex   = &[[\\^] (chs / par / misc)*
    // "regex": ([_, rs]) => rs[0]==='^'? 
    //             ["^", rs.slice(1).join('')] : ["^", rs.join('')],

    // regex   = &[[\\^] (chs / par / misc)*
    "regex": ([_, rs]) => rs[0] && rs[0][0]==='^'? 
                ["^", rs[0].slice(1)+rs.slice(1).join('')]
                : ["^", rs.join('')],

    // par = [(] ([^()]* par?)* [)]
    "par": ([lp, ps, rp]) => { // par? => p, will be already done..
        var xps = ps.map(([x, p]) => p? x+p : x);
        return lp + xps.join('') + rp; 
    },

    // act = ":" lines
    "act": ([_, line, lines]) => {
        return string([line, lines]);
    },

    // ws = \s*
    "ws": (s) => s

} // grit_actions

function esc_regex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function rules_map(code) {
    return code.reduce((rm, rule, idx) => {
        rm[rule.name] = idx; return rm; }, {});
}

function resolve_code(code) {
    var name_idx = rules_map(code);

    function resolve (op) {
        if (!Array.isArray(op)) return op;
        if (op[0] === "^") {
            op[2] = op[2] || new RegExp(op[1],"yus"); // sticky unicode dots flags
            return op;
        }
        if (op[0] === "=") {
            op[2] = name_idx[op[1]];
            if (!op[2] && op[2]!==0) {
                throw new Error("*** missing rule '"+op[1]+"' ... ")
            }
            return op;
        }
        return op.map((x) => resolve(x));
    }
    var coded = code.map((rule) => {
        return resolve(rule.code);
    });

    return code;
}
    
// -- parser -- string-code interpreter ------------------------------------

const ANON = "__anon__"; // default name for first rule

function parser (code, input, actions={}, options={}) {
    var pos = 0;
    var inRule = "start"; // current rule trace 
    var ruleStack = [];
    var maxPos = 0; // high water mark
    var maxRule= ""; // inRule at maxPos
    var runOps = 0;
    var maxOps = 10000; // run away recursion check

    if (!code) {
        return report("missing grammar rule code...");
    }

    var start_name = code[0].name;
    var start = ["=", start_name, 0];

    if (typeof input !== "string") {
        try { // tag`grammar..` => tag([grammar...], ${}...)
            input = String.raw(input);
            if (!input.match(/^\s*\S+\s*=/)) {
                input = ANON+" = "+input; // simple regex grammar
            }
        } catch(err) {
            input = '';
            return report("input is not a string...");
        }
    }

    if (typeof actions === 'function') {
        actions = { "?": actions } // catch all
    }

    if (options.trace) console.log("trace", start_name)

    var result = run(start); // run the parser engine...

    if (result === null) {
        return report("failed");
    }
    if (pos < input.length && !input.slice(pos).match(/^\s+$/)) {
        if (options.replay) replay();
        return report("fell short");
    }
    return [result, pos];

    // -- code engine -------------------------------------------

    function run(op) {

        if (runOps += 1 > maxOps) {
            return report("run away recursion...");
        }

        switch (op[0]) {

        case '^': // ["^", src, regex]
            var regex = op[2]; 
            regex.lastIndex = pos; // using regex.y sticky flag
            var mx = regex.exec(input);
            var trace = options.trace;
            if (trace) {
                if (typeof trace !== "string" || trace === inRule) {
                    var span = pos;
                    span += mx? ".."+(pos+mx[0].length) : ""
                    var match = mx? "=>"+mx[0] : "!";
                    console.log(span,inRule,regex,match);
                }
            }
            if (!mx) return null;
            pos += mx[0].length;
            if (pos > maxPos) { 
                maxPos = pos; 
                maxRule = inRule;
            }
            // return mx[1]||mx[0]; // used to skip white-space prefix
            if (mx.length === 1) return mx[0];
            if (mx.length === 2) return mx[1];
            return mx.slice(1);

        case '=': // ["=", name, idx]
            var idx = op[2];
            var rule = code[idx];
            if (!rule) { // bad grammar ...
                return report("missing rule "+idx+": '"+op[1]+"' ...");
            }
            ruleStack.push(inRule)
            inRule = op[1];
            var start = pos;
            var result = run(rule.code);
            inRule = ruleStack.pop();
            if (result === null) {
                pos = start;
                return null;
            }
            var {name, action} = rule;
            var val = run_action(result, {name, action, pos, input, posit, env:options});
            if (val !== null) return val;
            pos = start; // fail
            return null;

        case ',': // [",", ..., seq, ... ]
            var start = pos;
            var res = [];
            var i = 1;
                while (i < op.length) {
                var temp = run(op[i]);
                if (temp === null) {
                    pos = start;
                    return null;
                }
                res.push(temp);
                i += 1;
            }
            return res;

        case '/': // ["/", ..., alt, ... ]
            var start = pos;
            var res = null; // fail if no alt
            var j = 1;
            while (j < op.length) {
                res = run(op[j]);
                if (res !== null && pos > start) {
                    return res;
                }
                pos = start;
                j += 1;
            }
            return res;

        case '*': // ["*", op]
        var start = pos;
        var temp = run(op[1]);
        if (temp === null) return [];
        var res = [temp];
        while (true) {
            start = pos;
            temp = run(op[1]);
            if (temp === null || pos === start) break;
            res.push(temp);
        }
        return res;

        case '+': // ["+", op]
            var start = pos;
            var temp = run(op[1]);
            if (temp === null) return null;
            var res = [temp];
            while (true) {
                start = pos;
                temp = run(op[1]);
                if (temp === null || pos === start) break;
                res.push(temp);
            }
            return res;

        case '?': // ["?", op]
            var res = run(op[1])
            if (res === null) return "";
            return res;

        case '!': // ["!", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res === null) return "";
            return null;

        case '&': // ["&", op]
            var start = pos
            var res = run(op[1])
            pos = start
            if (res !== null) return "";
            return null;

        default: // should never happen...
            throw new Error("*** Undefined parse code op: "+JSON.stringify(op));
        }
    } // run

    function report(msg) {
        var [line, col] = line_of(pos);
        var lx = " "+line+"."+col;
        // var at = pos + (maxPos>pos? ".."+maxPos : "") + " of " + input.length;
        //var pre = pos<16? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var pre = line<2? input.slice(0,pos) : "..."+input.slice(pos-13,pos);
        var show = pre + input.slice(pos,pos+40);
        show = show.replace(/[\x00-\x1f]/g,(c) => {
            if (c === "\n" || c === "r") return "\u00AC";
            if (c === "\t") return "\u2023"
            return "\u00A4";
        })
        // show = show.replace(/[\x00-\x1f]/g,"¬")
        if (input.length > pos+40) show += "..."
        var cursor = "";
        for (var i=0; i < pre.length; i+=1) cursor += " ";
        cursor += "^";
        if (maxPos > pos) {
            var max = maxPos-pos>40? 42 : maxPos;
            for (var i=pos+1; i < max; i+=1) cursor += " ";
            cursor += "^";
        }
        var report;
        if (start_name == "__grit__grammar") {
            report = "*** grammar rule syntax err, line:"+lx+
                    "\n"+show+"\n"+cursor;
        } else {
            report = "*** grammar '"+start_name+"' parse "+msg+
                    "\n'"+maxRule+"' at line:"+lx+
                    "\n"+show+"\n"+cursor;
        };
        if (!options || (!options.silent && !options.console)) {
            throw new Error(report);
        } else if (options.console && !options.silent) {
            console.log(report);
        } else { // silent reporting...
            options.report = report;
        }
        return [null, pos];
    }

    function line_of(pos) {
        let ln = 1, col = 0;
        for (let i = 0; i <= pos; i+=1) {
            const char = input[i];
            if (char === "\n") {
                ln += 1;
                col = 0;
            } else if (char === "\r") { // \r\n?
                if (i < pos && input[i+1] === "\n") i += 1;
                ln += 1;
                col = 0;
            } else col += 1;
        };
        return [ln, col];
    }

    function replay() {
        try {
            parser(code, input, actions, {trace:true});
        } catch(err) {
            // console.log(err);
        }
    }

    function posit(n) {
        // console.log("posit", pos, n);
        pos = n;
    }

    var cache = {};

    function run_action(result, parse) {
        var fn = null;
        var {name, action} = parse; // {name, action, pos, input, posit, env}
        if (action) {
            var ax = action.match(/^\s*(\S+)/);
            act = ax? ax[1] : "";
            fn = actions[act] || std_actions[act];
            if (!fn) { // synthetic action: _x_ etc..
                if (act.match(/^[_x]+$/) && Array.isArray(result)) {
                    var res = [];
                    result.forEach((x, i) => {
                        var k = act[i];
                        if (k === "x") res.push(x);
                    });
                    if (res.length === 1) return res[0];
                    return res;
                } else if (act) { // undefined action name...
                    report(`Missing action: '${act}' for rule: '${name}' ...`);
                }            
            }
        } // action
        const action_function = fn || actions[name] || actions["?"];
        if (action_function) {
            try {
                return action_function(result, parse);
                // return fn(result, {...parse, _:parse, $:parse.cache });
            } catch(err) {
                report("Bad action for '"+name+"':\n"+err);
            }
        }
        return result // [name, result] // default result..
    }


} // parser

// -- built-in semantic actions ---------------------------------------------

const std_actions = {

    yfx: ([x, ys]) => // x (op y)* => [op,x,y]
        ys.reduce((y, [op, z]) => [op, y, z], x),

    xfy: function xfy([x, ys]) {
        if (!ys || ys.length < 1) return x;
        let [[op,y], ...zs] = ys;
        return [op, x, xfy([y, zs])];
    },

    yfy: ([a, bs]) => { // a (op b)* => [a,op,b,op,c,...]
        return bs.reduce((y, b) => y.concat(b), [a])
    },

    xfx: ([a, bs]) => { // a (_ b)* => [a,b,c,...]
        return bs.reduce((y, [_, b]) => y.concat(b), [a]);
    },

    _x: ([_,x]) => x,

    flatten: (xs) => flatten(xs),

    string: (xs) => string(xs),

    number: (xs) => Number(string(xs)),

    x: (result) => result,
    n: (result) => Number(result),
    _: (result) => ""

}

function flatten(xs) {
    return Array.isArray(xs)?
        xs.reduce((y,x) => y.concat(flatten(x)),[]) : xs;
}

function string(xs) {
    return Array.isArray(xs)? flatten(xs).join('') : xs;
}

// == Operator expression function ==============================

function operex(...op_spec) { // => opex parser function

    const opdef = encodeOps(op_spec);

    /* == operator defintions ==
        const opex = operex(
            ["fy", "+", "-"],   // prefix, tightly bound
            ["xfy", "^"],
            ["yfx", "*", "/"],
            ["yfx", "+", "-"],
            ["xfy", "="]         // loosely bound
        );

        The operators are encoded into an op key map: opdef,
        indexed n = 1,3,5,7,..., binding strength, tighest = 1
        binding strengths: [prefix, left, right, suffix]:
            fx =>  [n,0,0,0];
            fy =>  [n+1,0,0,0]; 
            xfx => [0,n,n,0];   // [pfx,left,right,sfx]
            yfx => [0,n+1,n,0];
            xfy => [0,n,n+1,0];
            xf =>  [0,0,0,n];
            yf =>  [0,0,0,n+1];

        opdef = {
            "+": [1,8,7,0],  // fy , yfx
            "-": [1,8,7,0],
            "^": [0,3,4,0],  // xfy left < right
            "*": [0,6,5,0],  // yfx left > right
            ...
        }

        node = [op, left, right]
            left == null => prefix
            right == null => suffix
    */
    const nodePower = (node) => {
        if (!Array.isArray(node)) return 0;   // e.g operad
        let [op, left, right] = node;
        if (!opdef[op]) return 0;             // e.g "()"
        if (!left) return prefixPower(op);
        if (!right) return suffixPower(op);
        return infixRight(op);
    }  
    const prefixPower = (op) => opdef[op][0];
    const infixLeft = (op) => opdef[op][1];
    const infixRight = (op) => opdef[op][2];
    const suffixPower = (op) => opdef[op][3];

    const isPrefix = (op) => opdef[op] && opdef[op][0]>0;
    const isInfix = (op) => opdef[op] && opdef[op][1]>0;
    const isSuffix = (op) => opdef[op] && opdef[op][3]>0;

    const is_fy = (op) => opdef[op][0]%2==0;
    const is_yf = (op) => opdef[op][3]%2==0;

    const isOp = (op) => opdef[op];
    const notOp = (op) => !opdef[op];


    // -- encode operators ---------------------------------------------------

    function encodeOps(ops) {
        const opdef = {};
        ops.map((op, i) => { // eg  op = ["yfx", "+", "-"]
            const n = 2*i+1; // 2,4,6,8,...
            op.slice(1).map((sym) => {
                const defn = opdef[sym] || [0,0,0,0];
                const type = op[0];
                if (type === "fx") defn[0] = n;
                else if (type === "fy") defn[0] = n+1;
                else if (type === "xfx") {defn[1] = n; defn[2] = n; }
                else if (type === "xfy") {defn[1] = n; defn[2] = n+1; }
                else if (type === "yfx") {defn[1] = n+1; defn[2] = n; }
                else if (type === "xf") defn[3] = n;
                else if (type === "yf") defn[3] = n+1;
                opdef[sym] = defn; 
            });
        });
        return opdef;
    }

    const op_type = (op) => { // decode...
        const defn = opdef[op];
        if (!defn) return "undefined";
        var sign = "";
        if (defn[0]>0) sign += defn[0]%2==0? "fx":"fy";
        if (defn[1]>0 && defn[1]==defn[2]) sign += " xfx";
        if (defn[1]<defn[2]) sign += " xfy";
        if (defn[1]>defn[2]) sign += " yfx";
        if (defn[3]>0) sign += defn[0]%2==0? " xf":" yf";
        return sign;
    }


    // -- parser ---------------------------------------------------

    function opex(xs) { // xs = tokens...
        //     console.log("opex",xs);
        var tree=[], pos=0;

        if (xs.length === 0) return "";
        if (xs.length === 1) return xs[0];

        // p=prefix, i=infix, s=suffix, x,y=operands
        // valid:  p* x (s* (i p* y)?)? 
        tree = prefixed(); // tree = p* x

        while (pos < xs.length) { // valid: s* (i p* y)?
            var op = xs[pos++];
            if (isSuffix(op) && (!isInfix(op) || !xs[pos] || isOp(xs[pos]))) {
                tree = insertSuffix(tree, op);
                continue;
            }
            if (!isInfix(op)) { // (i p* y)?
                let msg = `expecting infix operator, found: '${op}' ${op_type(op)}`;
                fault(tree, [op], msg);
            }
            var y = prefixed();
            tree = insertInfix(tree, op, y);
        }
        return tree

        function prefixed() { // p* x => 
            var k = pos;
            while (k<xs.length && isPrefix(xs[k])) k+=1;
            if (isOp(xs[k])) { // p* !x
                let msg = `expecting operand, found: '${xs[k]}' ${op_type(op)}`;
                fault(tree, xs.slice(pos,k+1), msg);
            }
            if (k === pos) return xs[pos++]; // x
            var pfx = xs[pos++];
            var result = [pfx, null, xs[pos++]];
            return prefixChain(result, k);
        }
        function prefixChain(node, k) { // p+ x => p(p(..p(x))..)
            if (pos > k) return node;
            var [pfx1, _, pfx2] = node;
            if (prefixPower(pfx1) > prefixPower(pfx2)) {
                let msg = `prefix conflict: '${pfx1}' ${op_type(pfx1)}, '${pfx2}' ${op_type(pfx2)}`;
                fault(tree, xs.slice(pos-1,pos+1), msg);
            }
            node[2] = prefixChain([pfx2, null, xs[pos++]], k);
            return node;
        }

    } // opex

    const insertInfix = (tree, op, z, m = infixLeft(op)) => {
        let n = nodePower(tree);
        if (n < m || !tree[2]) return [op, tree, z];
        if (isLeaf(tree[2])) {
            tree[2] = [op, tree[2], z];
            return tree;
        }
        if (n > m) {
            tree[2] = insertInfix(tree[2], op, z, m);
            return tree;
        }
        fault(tree, [op, z], `invalid '${op}' ${op_type(op)}`);
    }

    const insertSuffix = (tree, sfx, m = suffixPower(sfx)) => {
        let n = nodePower(tree);
        if (n < m || !tree[2]) return [sfx, tree, null];
        if (isLeaf(tree[2])) {
            tree[2] = [sfx, tree[2], null];
            return tree;
        }
        if (n > m) {
            tree[2] = insertSuffix(tree[2], sfx, m);
            return tree;
        }
        if (n === m && is_yf(sfx)) { // must be yf
            tree[2] = [sfx, tree[2], null];
            return tree;
        }
        fault(tree, [sfx, null], `invalid '${sfx}' ${op_type(sfx)}`);
    }

    const isLeaf = (x) => !x || !Array.isArray(x) || notOp(x[0]);

    const fault = (tree, rest, msg) => {
        const ast = JSON.stringify(tree);
        throw new Error(`Bad op expr: ${msg}\n${ast} ${rest.join(" ")}`);
    }

    return opex;
} // operex
    
// -- grit_parser --------------------------------------------------------

function grit_parser (grammar, actions) {

    let [code, _] = parser(grit_code, grammar, grit_actions)

    if (!code) return null;
    
    resolve_code(code);

    function parse(input, options) {
        const [result, pos] = parser(code, input, this.actions, options);
        this.result = {input, pos, result};
        return result;
    };

    function match(input, options) {
        try {
            var result = this.parse(input, options);
        } catch(err) {
            this.err = err;
            return null;
        }
        return result;
    }

    return {parse, match, grammar, actions, code};
}


// expose grit_parser ----------------------------------------------

grit_parser.operators = operex;

// module.exports = grit_parser;

if (typeof module !== 'undefined' && typeof exports === 'object') {
    module.exports = grit_parser;
} else if (typeof define === 'function' && define.amd) {
    define(function() { return grit_parser; });
} else {
    this.grit_parser = grit_parser;
}

}).call(function() {
return this || (typeof window !== 'undefined' ? window : global);
}()); // outer funtion name-space wrapper
    
    
</script>
<script>
    // window.gritbox -- global variable for gritbox HTML events to use.
    // expects grit-prser in: window.grit_parser, see below (line 33)....
    if (window.gritbox) throw new Error("Browser window.gritbox already in use? ...");
    window.gritbox = {};
    var gritbox = window.gritbox

    gritbox.RESET = (i) => {
	    var src = gritbox.textarea_src(i)
        var example = gritbox.example(i, 0)
	    src.value = example.value
	    gritbox.RUN(i);
    }
    gritbox.RUN = (i) => {
        var src = gritbox.textarea_src(i)
        var dst = gritbox.textarea_dst(i)
        var res = "";
        try {
            var verbs = {
                grit: window.grit_parser, // See above...
                operex: window.operex,
                write: (txt) => res += JSON.stringify(txt)+"\n",
                print: (txt) => res += JSON.stringify(txt, null, 2),
                nl: () => res += "\n"
            }
            var keys = Object.keys(verbs);
            var vals = keys.map((k)=> verbs[k])
            var fn = new Function(...keys, src.value)
            fn(...vals);
        } catch(err) {
            res = err
        }
        dst.value = res;
    }
    gritbox.SELECT = (i) => {
        var x = document.getElementById("gritbox-select-"+i).value;
        var example = gritbox.example(i, x-1)
        var src = gritbox.textarea_src(i)
        src.value = example.value
        gritbox.RUN(i);
    }
    gritbox.textarea_src = (i) => document.getElementById('gritbox-src-'+i);
    gritbox.textarea_dst = (i) => document.getElementById('gritbox-dst-'+i);
    gritbox.example = (i, n) => document.getElementById('gritbox-eg-'+i+'-'+n);
</script>
<style>
textarea {font-family: monospace; font-size:10pt; background:whitesmoke;}
</style>

</head>
<body>
<h1>Operator Expression Parsing</h1>
<p>An operator expression can be any kind of symbolic expression with operators and operands. Arithmetic expressions make good examples, but in other applications the operators and operands can be used to represent almost anything. 
</p>
<p>The objective is to parse an operator expressions into a parse tree data structure, also known as an AST (Abstract Syntax Tree).
</p>
<h2>Baisc Concepts</h2>
<p>Parsing an operator expression boils down to adding parentheses correctly around associated operators and operands. An initial expression need not have any parentheses, but after it is parsed it will have a full set of parentheses.
</p>
<p>It might seem logical to simply add parentheses from left to right:
</p>
<pre class="code"><code>    1+2*3   ==>   ((1+2)*3)   ==>  9</code></pre>
<p>But by convention multiplication has a higher <em>precedence</em> than addition:
</p>
<pre class="code"><code>    1+2*3   ==>   (1+(2*3))  ==>  7</code></pre>
<p>Operators with the same precedence usually <em>associate</em> from left to right:
</p>
<pre class="code"><code>    10-4-3-2  ==>  (((10-4)-3)-2)  ==>  1       Not:  (10-(4-(3-2)))  ==> 7</code></pre>
<p>But there are exceptions, exponents associate from right to left:
</p>
<pre class="code"><code>    2**3**4   ==>  (2**(3**4))  ==>  2**81      Not: ((2**3)**4)  ==> 2**12      </code></pre>
<p>To parse an operator expression the parser needs to know the operators <em>precedence</em> and <em>associativity</em>.
</p>
<h2>Operator Notation</h2>
<p>We will borrow the notation for operator precedence and associativity used in <a href='https://www.swi-prolog.org/pldoc/man?section=operators'>Prolog</a>.
</p>

<p>The notation <code>yfx</code> represents an infix operator that associates to the left, and <code>xfy</code> for an infix operator that associates to the right. An <code>xfx</code> operator does not associate to the left or the right (only one of these operators is expected in an un-bracketed expression).
</p>
<p>The notation reads like a picture, the <code>f</code> is the operator and the <code>x</code> or <code>y</code> are the expression on the left or right of the operator. The <code>y</code> indicates that the operator can associate in this position. In other words, several operators with equal or higher precedence may appear in the expression in the <code>y</code> position, but only operators with strictly higher precedence can appear in the <code>x</code> position.
</p>
<p>An <code>fy</code> or <code>fx</code> are prefix operators, and <code>xf</code> or <code>yf</code> are suffix operators. There are seven possible operator signatures:
</p>
<pre class="code"><code>fx  fy   xfx xfy yfx   yf  xf</code></pre>
<p>For example, basic arithmetic operators can be defined like this, in order of precedence, high to low:
</p>
<pre class="code"><code>xfy   **     highest precedence, associates to the right.
yfx   *      associates to the left.
yfx   + 
xfx   =      lowest precedence, will not associate left or right.
</code></pre>
<p>Given these definitions this expression will parse like this:
</p>
<pre class="code"><code>x = a+(b*c)**2   ==>   (x=(a+((b*c)**2)))</code></pre>
<p>With these definitions the <q><code>=</code></q> operator does not associate to the left or the right, so there can not be two <q><code>=</code></q> operators in an expression. In programming languages where <q><code>=</code></q> is an assignment operator it may be defined as <code>xfy</code> to allow it to associate to the right.
</p>
<p>There may be several operators with the same signature and precedence, and the same operator symbol may be defined with more than one signature. In arithmetic a <q><code>+</code></q> operator may be defined as a <code>fy</code> prefix operator as well as a <code>yfx</code> infix operator.
</p>
<p>Here is a larger example with operators in five precedence levels:
</p>
<pre class="code"><code>fy    +  -
xfy   ** 
yfx   *  /  //  div  rdiv  &lt;&lt;  >>  mod  rem
yfx   +  -  /\  \/  xor 
xfx   &lt;  =  =&lt;  ==  =\=  >  >=  \=  \==  as  is  </code></pre>
<p>The prefix operators at the top have high precedence and bind their operands tightly, the comparison operators at the bottom have low precedence and bind loosely over larger operand expressions.
</p>
<p>For example:
</p>
<pre class="code"><code>a+b*c >= d**2  ==>  ((a+(b*c))>=(d**2))</code></pre>
<p>The compare operators have an <code>xfx</code> signature, so they can not associate. An expression such as: <code>x > y > z</code> makes no sense (except in Python and Julia where it it is interpreted to mean: <code>x > y and y > z</code>).
</p>
<h2>Grammar Rules</h2>
<p>Here is a bare minimum grammar to match input operator expressions:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(1)' >Example 1</button>
    <button onClick='gritbox.RUN(1)'>RUN</button>
  </div>
  <textarea id='gritbox-src-1' style="width:49%" rows=7>const expr = grit`
    expr   = term (op term)*
    op     = "+" / "-" / "*" / "/"
    term   = \w+
`;

write(expr.parse("1+2*3"));</textarea>
  <textarea id='gritbox-dst-1' style="width:49%" rows=7></textarea>
  
      <textarea id='gritbox-eg-1-0' hidden>const expr = grit`
    expr   = term (op term)*
    op     = "+" / "-" / "*" / "/"
    term   = \w+
`;

write(expr.parse("1+2*3"));</textarea>
  <script>gritbox.RUN(1)</script><br>


<p>This grammar takes no account of precedence or association, it simply matches a sequence of terms and operators. 
</p>
<p>To take account of precedence the operators can be split into separate grammar rules, one for each precedence level:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(2)' >Example 2</button>
    <button onClick='gritbox.RUN(2)'>RUN</button>
  </div>
  <textarea id='gritbox-src-2' style="width:49%" rows=9>const expr = grit`
    add    = mult (op2 mult)*
    mult   = term (op1 term)*
    op1    = "*" / "/"
    op2    = "+" / "-"
    term   = \w+
`;

write(expr.parse("1+2*3"));</textarea>
  <textarea id='gritbox-dst-2' style="width:49%" rows=9></textarea>
  
      <textarea id='gritbox-eg-2-0' hidden>const expr = grit`
    add    = mult (op2 mult)*
    mult   = term (op1 term)*
    op1    = "*" / "/"
    op2    = "+" / "-"
    term   = \w+
`;

write(expr.parse("1+2*3"));</textarea>
  <script>gritbox.RUN(2)</script><br>

<p>The <code>mult</code> rule will match the <code>*</code> or <code>/</code> operator with its operands before the <code>add</code> rule matches the <code>+</code> or <code>-</code> operators with their operands. In other words the the <code>op1</code> operators have higher precedence and bind tighter than the <code>op2</code> operators.
</p>
<p>There is no left (or right) association between operators of the same precedence, the grammar matches the input into a flat list of operators and operands. The parse tree resulting from this grammar directly reflects the input format (pattern matching).
</p>
<p>For a <code>yfx</code> left associative operator we want the parse tree to group the terms so that they are nested on the left. The traditional approach is to to use left recursion in the grammar rules, instead of this we are going to use a semantic action function. This allows us to keep the grammar rules as simple input pattern matching recognizer rules.
</p>
<p>An action functions can be used to process the rule results into a nice AST with a left associative nested tree structure.
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(3)' >Example 3</button>
    <button onClick='gritbox.RUN(3)'>RUN</button>
  </div>
  <textarea id='gritbox-src-3' style="width:49%" rows=14>const expr = grit`
    add    = mult (op2 mult)*  : yfx
    mult   = term (op1 term)*  : yfx
    op1    = "*" / "/"
    op2    = "+" / "-"
    term   = \w+
`;

expr.actions = {
    yfx: ([x,xs]) => xs.reduce(
            (t,[op,y]) => [op,t,y], x),
}

write(expr.parse("1+2*3"));</textarea>
  <textarea id='gritbox-dst-3' style="width:49%" rows=14></textarea>
  
      <textarea id='gritbox-eg-3-0' hidden>const expr = grit`
    add    = mult (op2 mult)*  : yfx
    mult   = term (op1 term)*  : yfx
    op1    = "*" / "/"
    op2    = "+" / "-"
    term   = \w+
`;

expr.actions = {
    yfx: ([x,xs]) => xs.reduce(
            (t,[op,y]) => [op,t,y], x),
}

write(expr.parse("1+2*3"));</textarea>
  <script>gritbox.RUN(3)</script><br>

<p>The action function has been called <code>yfx</code> for obvious reasons, and it can be implemented with a standard list reduce function. It produces an AST with nodes in operator prefix format:
</p>
<pre class="code"><code>                          +
                         / \
    (+,1,(*,2,3)) &lt;==>  1   *
                           / \
                          2   3</code></pre>
<p>Adding more operators into this two level precedence grammar is simple:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(4)' >Example 4</button>
    <button onClick='gritbox.RUN(4)'>RUN</button>
  </div>
  <textarea id='gritbox-src-4' style="width:49%" rows=14>const expr = grit`
    expr   = fact (op2 fact)*  : yfx
    fact   = term (op1 term)*  : yfx
    op1    = "*" / "/" /"<<"/">>"/"mod"/"rem"
    op2    = "+" / "-" /"and"/"or"/"xor"
    term   = \w+
`;

expr.actions = {
    yfx: ([x,xs]) => xs.reduce(
            (t,[op,y]) => [op,t,y], x)
}

write(expr.parse("1+2*3 mod 4+5"));</textarea>
  <textarea id='gritbox-dst-4' style="width:49%" rows=14></textarea>
  
      <textarea id='gritbox-eg-4-0' hidden>const expr = grit`
    expr   = fact (op2 fact)*  : yfx
    fact   = term (op1 term)*  : yfx
    op1    = "*" / "/" /"<<"/">>"/"mod"/"rem"
    op2    = "+" / "-" /"and"/"or"/"xor"
    term   = \w+
`;

expr.actions = {
    yfx: ([x,xs]) => xs.reduce(
            (t,[op,y]) => [op,t,y], x)
}

write(expr.parse("1+2*3 mod 4+5"));</textarea>
  <script>gritbox.RUN(4)</script><br>

<p>Adding extra precedence levels or new operator signatures requires extra rules. The pattern of grammar rules corresponding to operator precedence levels should be apparent:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(5)' >Example 5</button>
    <button onClick='gritbox.RUN(5)'>RUN</button>
  </div>
  <textarea id='gritbox-src-5' style="width:49%" rows=26>const expr = grit`
    expr   = exp3 (op4 exp3)*  : xfy
    exp3   = exp2 (op3 exp2)*  : yfx
    exp2   = exp1 (op2 exp1)*  : yfx
    exp1   = term (op1 term)*  : xfy
    op1    = "^"
    op2    = "*" / "/" /"<<"/">>"/"mod"/"rem"
    op3    = "+" / "-" /"and"/"or"/"xor"
    op4    = "=" / "\=" / "<"/"<="/">"/">="
    term   = atom / group
    group  = "(" expr ")"
    atom   = \s*(\w+)
`;
expr.actions = {
    yfx: ([x, ys]) => ys.reduce(
        (y, [op, z]) => [op,y,z], x),

    xfy: function xfy([x, ys]) {
        if (!ys || ys.length < 1) return x;
        let [[op,y], ...zs] = ys;
        return [op, x, xfy([y,zs])];
    },
    group: ([_,expr]) =>  expr
}

write(expr.parse("x = (y mod z)^2 + 4"));</textarea>
  <textarea id='gritbox-dst-5' style="width:49%" rows=26></textarea>
  
      <textarea id='gritbox-eg-5-0' hidden>const expr = grit`
    expr   = exp3 (op4 exp3)*  : xfy
    exp3   = exp2 (op3 exp2)*  : yfx
    exp2   = exp1 (op2 exp1)*  : yfx
    exp1   = term (op1 term)*  : xfy
    op1    = "^"
    op2    = "*" / "/" /"<<"/">>"/"mod"/"rem"
    op3    = "+" / "-" /"and"/"or"/"xor"
    op4    = "=" / "\=" / "<"/"<="/">"/">="
    term   = atom / group
    group  = "(" expr ")"
    atom   = \s*(\w+)
`;
expr.actions = {
    yfx: ([x, ys]) => ys.reduce(
        (y, [op, z]) => [op,y,z], x),

    xfy: function xfy([x, ys]) {
        if (!ys || ys.length < 1) return x;
        let [[op,y], ...zs] = ys;
        return [op, x, xfy([y,zs])];
    },
    group: ([_,expr]) =>  expr
}

write(expr.parse("x = (y mod z)^2 + 4"));</textarea>
  <script>gritbox.RUN(5)</script><br>

<p>These four precedence levels could have been given names, such as: <code>exponential</code>, <code>multiplicative</code>, <code>additive</code>, and <code>comparative</code>. But it is only the order of precedence between operators that really matters.
</p>
<p>The <code>xfy</code> right associate operators require a slightly more complicated action function.
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(6)' >Example 6</button>
    <button onClick='gritbox.RUN(6)'>RUN</button>
  </div>
  <textarea id='gritbox-src-6' style="width:49%" rows=28>const expr = grit`
    expr   = exp3 (op4 exp3)*      : xfy
    exp3   = exp2 (op3 exp2)*      : yfx
    exp2   = exp1 (op2 exp1)*      : yfx
    exp1   = exp0 (op1 exp0)*      : xfy
    exp0   = op0 exp0 / term
    op0    = '+' / '-' / '!' / '~'
    op1    = "^"
    op2    = "*" / "/" /"<<"/">>"/"mod"/"rem"
    op3    = "+" / "-" /"and"/"or"/"xor"
    op4    = "=" / "\=" / "<"/"<="/">"/">="
    term   = atom / group
    group  = "(" expr ")"
    atom   = \s*(\w+)
`;
expr.actions = {
    yfx: ([x, ys]) => ys.reduce(
        (y, [op, z]) => [op,y,z], x),

    xfy: function xfy([x, ys]) {
        if (!ys || ys.length < 1) return x;
        let [[op,y], ...zs] = ys;
        return [op, x, xfy([y,zs])];
    },
    group: ([_,expr]) =>  expr
}

write(expr.parse("x = (y mod z)^2 + 4"));</textarea>
  <textarea id='gritbox-dst-6' style="width:49%" rows=28></textarea>
  
      <textarea id='gritbox-eg-6-0' hidden>const expr = grit`
    expr   = exp3 (op4 exp3)*      : xfy
    exp3   = exp2 (op3 exp2)*      : yfx
    exp2   = exp1 (op2 exp1)*      : yfx
    exp1   = exp0 (op1 exp0)*      : xfy
    exp0   = op0 exp0 / term
    op0    = '+' / '-' / '!' / '~'
    op1    = "^"
    op2    = "*" / "/" /"<<"/">>"/"mod"/"rem"
    op3    = "+" / "-" /"and"/"or"/"xor"
    op4    = "=" / "\=" / "<"/"<="/">"/">="
    term   = atom / group
    group  = "(" expr ")"
    atom   = \s*(\w+)
`;
expr.actions = {
    yfx: ([x, ys]) => ys.reduce(
        (y, [op, z]) => [op,y,z], x),

    xfy: function xfy([x, ys]) {
        if (!ys || ys.length < 1) return x;
        let [[op,y], ...zs] = ys;
        return [op, x, xfy([y,zs])];
    },
    group: ([_,expr]) =>  expr
}

write(expr.parse("x = (y mod z)^2 + 4"));</textarea>
  <script>gritbox.RUN(6)</script><br>

<p>It is not necessary to have a large number of precedence levels, most users will only be able to remember a small number. It is considered good practice to use explicit parentheses to make the precedence clear.
</p>
<p>Operator precedence levels provide a convenient short-hand to avoid parentheses, but they are not essential. APL, Smalltalk, and Lisp, are examples of programming languages that do without any operator precedence levels.
</p>
<p>However, general purpose programming languages can define quite a large number of different precedence levels (C defined 15, JavaScript has more than 20). In that case having a grammar rule for each precedence level becomes unwieldy, and a special purpose parser may be a better option.
</p>
<h2>Operator Expression Parser</h2>
<p>Grit provides a special purpose parser for operator expressions. This is an <code>operators</code> function that takes a list of operator definitions and returns an action function that can transform the tokens of an operator expression into a prefix format parse tree.
</p>
<p>This allows the previous example to be written like this:
</p>

  <div class="gritbox controls">
    
      <button onClick='gritbox.RESET(7)' >Example 7</button>
    <button onClick='gritbox.RUN(7)'>RUN</button>
  </div>
  <textarea id='gritbox-src-7' style="width:49%" rows=18>const expr = grit`
    expr   = term*
    term   = atom / group
    group  = "(" expr ")"
    atom   = \s*(\w+|[=*/\\~^<>:.?@#$&+-]+)
`;
expr.actions = {
    expr: grit.operators(
        ["fy", "+", "-", "!", "~"],
        ["xfy", "^"],
        ["yfx", "*","/","<<",">>","mod","rem"],
        ["yfx", "+","-","and","or","xor"],
        ["xfx", "=" ,"\=","<","<=",">",">="] 
    ),
    group: ([_,expr]) => ["()", expr, null]
};

write(expr.parse("x = (y mod 12)^2 + 4"));</textarea>
  <textarea id='gritbox-dst-7' style="width:49%" rows=18></textarea>
  
      <textarea id='gritbox-eg-7-0' hidden>const expr = grit`
    expr   = term*
    term   = atom / group
    group  = "(" expr ")"
    atom   = \s*(\w+|[=*/\\~^<>:.?@#$&+-]+)
`;
expr.actions = {
    expr: grit.operators(
        ["fy", "+", "-", "!", "~"],
        ["xfy", "^"],
        ["yfx", "*","/","<<",">>","mod","rem"],
        ["yfx", "+","-","and","or","xor"],
        ["xfx", "=" ,"\=","<","<=",">",">="] 
    ),
    group: ([_,expr]) => ["()", expr, null]
};

write(expr.parse("x = (y mod 12)^2 + 4"));</textarea>
  <script>gritbox.RUN(7)</script><br>

<p>The <code>expr</code> grammar rule parses an input operator expression into a flat list of <code>term</code> tokens. The action function for the <code>expr</code> rule transforms the token list into a parse tree with an operator prefix format. The action function is generated by the <code>grit.operators</code> function, given a list of operator definitions.
</p>
<p>Notice that the operator expression parser is entirely controlled by the list of operator definitions. The operators are ordered from highest to lowest precedence. This action function takes a list of operator and operand tokens and incrementally builds a parse tree, using a technique inspired by the <a href='https://en.wikipedia.org/wiki/Pratt_parser'>Pratt</a> parser algorithm.
</p>

<p>In this example the grammar rules themselves are only being used as a <q>lexer</q> to generate a token (<code>term</code>) list. A more realistic example is likely to have more grammar rules for the tokens (e.g. to skip comments, and to parse literal objects).  There could also be higher level grammar rules for language features that contain operator expressions as component parts.
</p>
<p>The parse tree nodes are arrays with the format: <code>[op, left, right]</code> (the <code>left</code> and <code>right</code> values can be sub-trees or operand values). To build the tree incrementally the parser must be able to distinguish a tree node from a leaf element operand value.  The operand values are usually a string or number, but they may be any data type. If an operand value is an array type then it could be confused with a tree node. To avoid any confusion the operand value can be wrapped into a node with a <code>nop</code> operator (a do nothing identity function).
</p>
<p>Explicit parentheses in the source expression will be parsed as nested expression sub-trees, but these sub-trees must be seen as leaf elements (operands) in the larger AST. For this reason the <code>group</code> action function adds an extra array wrapper around the sub-tree to ensure that it will be seen as an leaf node (the <code>()</code> operator symbol acts as a <code>nop</code>).
</p>
<p>The <code>grit.operators</code> parser makes it easy to handle a large number of operators with a large number of precedence levels. It also enables new operators to be easily defined. A programming language may even allow operators to be dynamically defined, as is done in Prolog.
</p>
<h2>Conclusion</h2>
<p>Operator expressions can be used for a wide variety of applications, as special purpose notations, or the basis of a DSL (Domain Specific Language).
</p>
<p>The Grit parser offers two ways to implement operator expression parsing. A direct grammar rule implementation works well for a small number of operator precedence levels. But for a large number of precedence levels a special purpose <code>grit.operator</code> function can be used (to generate a grammar rule action function).
</p>
<p>A parser for any operator expression can be fully defined by a list of operator specifications, ordered by precedence. 
</p>
<p>A significant part of the syntax of many programming language can be defined in terms of operator expressions. In some cases almost the complete language can be defined as an operator expression. The Prolog language is a good example.
</p>
</body>
</html>
